{"version":3,"sources":["node_modules/@angular-architects/ngrx-toolkit/fesm2022/angular-architects-ngrx-toolkit.mjs","src/app/shared/store/auth.store.ts"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, signal, effect, inject, PLATFORM_ID, NgZone, computed, isSignal, untracked, isDevMode as isDevMode$1, DestroyRef } from '@angular/core';\nimport { watchState, getState, signalStoreFeature, withMethods, withHooks, patchState as patchState$1, withState, withComputed, withProps, withLinkedState } from '@ngrx/signals';\nimport { isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { Subject, switchMap, mergeMap, concatMap, exhaustMap, defer, tap, catchError, EMPTY, finalize, filter, map } from 'rxjs';\nimport { removeEntity, setAllEntities, updateEntity, addEntity } from '@ngrx/signals/entities';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { HttpClient, HttpEventType, HttpResponse } from '@angular/common/http';\nconst DEVTOOLS_FEATURE = Symbol('DEVTOOLS_FEATURE');\nfunction createDevtoolsFeature(options) {\n  return {\n    [DEVTOOLS_FEATURE]: true,\n    ...options\n  };\n}\n\n/**\n * If multiple instances of the same SignalStore class\n * exist, their devtool names are indexed.\n *\n * For example:\n *\n * ```typescript\n * const Store = signalStore(\n *   withDevtools('flights')\n * )\n *\n * const store1 = new Store(); // will show up as 'flights'\n * const store2 = new Store(); // will show up as 'flights-1'\n * ```\n *\n * With adding `withDisabledNameIndices` to the store:\n * ```typescript\n * const Store = signalStore(\n *   withDevtools('flights', withDisabledNameIndices())\n * )\n *\n * const store1 = new Store(); // will show up as 'flights'\n * const store2 = new Store(); //ðŸ’¥ throws an error\n * ```\n *\n */\nfunction withDisabledNameIndices() {\n  return createDevtoolsFeature({\n    indexNames: false\n  });\n}\nfunction throwIfNull(obj) {\n  if (obj === null || obj === undefined) {\n    throw new Error('');\n  }\n  return obj;\n}\n\n/**\n * Internal Service used by {@link withGlitchTracking}. It does not rely\n * on `effect` as {@link DefaultTracker} does but uses the NgRx function\n * `watchState` to track all state changes.\n */\nlet GlitchTrackerService = /*#__PURE__*/(() => {\n  class GlitchTrackerService {\n    #stores = {};\n    #callback;\n    get stores() {\n      return Object.entries(this.#stores).reduce((acc, [id, {\n        store\n      }]) => {\n        acc[id] = store;\n        return acc;\n      }, {});\n    }\n    onChange(callback) {\n      this.#callback = callback;\n    }\n    removeStore(id) {\n      this.#stores = Object.entries(this.#stores).reduce((newStore, [storeId, value]) => {\n        if (storeId !== id) {\n          newStore[storeId] = value;\n        } else {\n          value.destroyWatcher();\n        }\n        return newStore;\n      }, {});\n      throwIfNull(this.#callback)({});\n    }\n    track(id, store) {\n      const watcher = watchState(store, state => {\n        throwIfNull(this.#callback)({\n          [id]: state\n        });\n      });\n      this.#stores[id] = {\n        destroyWatcher: watcher.destroy,\n        store\n      };\n    }\n    notifyRenamedStore(id) {\n      if (Object.keys(this.#stores).includes(id) && this.#callback) {\n        this.#callback({\n          [id]: getState(this.#stores[id].store)\n        });\n      }\n    }\n    static {\n      this.Éµfac = function GlitchTrackerService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || GlitchTrackerService)();\n      };\n    }\n    static {\n      this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: GlitchTrackerService,\n        factory: GlitchTrackerService.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return GlitchTrackerService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * It tracks all state changes of the State, including intermediary updates\n * that are typically suppressed by Angular's glitch-free mechanism.\n *\n * This feature is especially useful for debugging.\n *\n * Example:\n *\n * ```typescript\n * const Store = signalStore(\n *   { providedIn: 'root' },\n *   withState({ count: 0 }),\n *   withDevtools('counter', withGlitchTracking()),\n *   withMethods((store) => ({\n *     increase: () =>\n *       patchState(store, (value) => ({ count: value.count + 1 })),\n *   }))\n * );\n *\n * // would show up in the DevTools with value 0\n * const store = inject(Store);\n *\n * store.increase(); // would show up in the DevTools with value 1\n * store.increase(); // would show up in the DevTools with value 2\n * store.increase(); // would show up in the DevTools with value 3\n * ```\n *\n * Without `withGlitchTracking`, the DevTools would only show the final value of 3.\n */\nfunction withGlitchTracking() {\n  return createDevtoolsFeature({\n    tracker: GlitchTrackerService\n  });\n}\n\n/**\n * Allows you to define a function to map the state.\n *\n * It is needed for huge states, that slows down the Devtools and where\n * you don't need to see the whole state or other reasons.\n *\n * Example:\n *\n * ```typescript\n * const initialState = {\n *   id: 1,\n *   email: 'john.list@host.com',\n *   name: 'John List',\n *   enteredPassword: ''\n * }\n *\n * const Store = signalStore(\n *   withState(initialState),\n *   withDevtools(\n *     'user',\n *     withMapper(state => ({...state, enteredPassword: '***' }))\n *   )\n * )\n * ```\n *\n * @param map function which maps the state\n */\nfunction withMapper(map) {\n  return createDevtoolsFeature({\n    map: map\n  });\n}\n\n/**\n * Provides the configuration options for connecting to the Redux DevTools Extension.\n */\nfunction provideDevtoolsConfig(config) {\n  return {\n    provide: REDUX_DEVTOOLS_CONFIG,\n    useValue: config\n  };\n}\n/**\n * Injection token for the configuration options for connecting to the Redux DevTools Extension.\n */\nconst REDUX_DEVTOOLS_CONFIG = new InjectionToken('ReduxDevtoolsConfig');\nlet DefaultTracker = /*#__PURE__*/(() => {\n  class DefaultTracker {\n    #stores = signal({}, ...(ngDevMode ? [{\n      debugName: \"#stores\"\n    }] : []));\n    get stores() {\n      return this.#stores();\n    }\n    #trackCallback;\n    #trackingEffect = effect(() => {\n      if (this.#trackCallback === undefined) {\n        throw new Error('no callback function defined');\n      }\n      const stores = this.#stores();\n      const fullState = Object.entries(stores).reduce((acc, [id, store]) => {\n        return {\n          ...acc,\n          [id]: getState(store)\n        };\n      }, {});\n      this.#trackCallback(fullState);\n    }, ...(ngDevMode ? [{\n      debugName: \"#trackingEffect\"\n    }] : []));\n    track(id, store) {\n      this.#stores.update(value => ({\n        ...value,\n        [id]: store\n      }));\n    }\n    onChange(callback) {\n      this.#trackCallback = callback;\n    }\n    removeStore(id) {\n      this.#stores.update(stores => Object.entries(stores).reduce((newStore, [storeId, state]) => {\n        if (storeId !== id) {\n          newStore[storeId] = state;\n        }\n        return newStore;\n      }, {}));\n    }\n    notifyRenamedStore(id) {\n      if (this.#stores()[id]) {\n        this.#stores.update(stores => {\n          return {\n            ...stores\n          };\n        });\n      }\n    }\n    static {\n      this.Éµfac = function DefaultTracker_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || DefaultTracker)();\n      };\n    }\n    static {\n      this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: DefaultTracker,\n        factory: DefaultTracker.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return DefaultTracker;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst currentActionNames = new Set();\nconst dummyConnection = {\n  send: () => void true\n};\n/**\n * A service provided by the root injector is\n * required because the synchronization runs\n * globally.\n *\n * The SignalStore could be provided in a component.\n * If the effect starts in the injection\n * context of the SignalStore, the complete sync\n * process would shut down once the component gets\n * destroyed.\n */\nlet DevtoolsSyncer = /*#__PURE__*/(() => {\n  class DevtoolsSyncer {\n    /**\n     * Stores all SignalStores that are connected to the\n     * DevTools along their options, names and id.\n     */\n    #stores = {};\n    #isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n    #trackers = [];\n    #devtoolsConfig = {\n      name: 'NgRx SignalStore',\n      ...inject(REDUX_DEVTOOLS_CONFIG, {\n        optional: true\n      })\n    };\n    /**\n     * Maintains the current states of all stores to avoid conflicts\n     * between glitch-free and glitched trackers when used simultaneously.\n     *\n     * The challenge lies in ensuring that glitched trackers do not\n     * interfere with the synchronization process of glitch-free trackers.\n     * Specifically, glitched trackers could cause the synchronization to\n     * read the current state of stores managed by glitch-free trackers.\n     *\n     * Therefore, the synchronization process doesn't read the state from\n     * each store, but relies on #currentState.\n     *\n     * Please note, that here the key is the name and not the id.\n     */\n    #currentState = {};\n    #currentId = 1;\n    #connection = inject(NgZone).runOutsideAngular(() => this.#isBrowser ? window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__.connect(this.#devtoolsConfig) : dummyConnection : dummyConnection);\n    constructor() {\n      if (!this.#isBrowser) {\n        return;\n      }\n    }\n    ngOnDestroy() {\n      currentActionNames.clear();\n    }\n    syncToDevTools(changedStatePerId) {\n      const mappedChangedStatePerName = Object.entries(changedStatePerId).reduce((acc, [id, store]) => {\n        const {\n          options,\n          name\n        } = this.#stores[id];\n        acc[name] = options.map(store);\n        return acc;\n      }, {});\n      this.#currentState = {\n        ...this.#currentState,\n        ...mappedChangedStatePerName\n      };\n      const names = Array.from(currentActionNames);\n      const type = names.length ? names.join(', ') : 'Store Update';\n      currentActionNames.clear();\n      this.#connection.send({\n        type\n      }, this.#currentState);\n    }\n    getNextId() {\n      return String(this.#currentId++);\n    }\n    /**\n     * Consumer provides the id. That is because we can only start\n     * tracking the store in the init hook.\n     * Unfortunately, methods for renaming having the final id\n     * need to be defined already before.\n     * That's why `withDevtools` requests first the id and\n     * then registers itself later.\n     */\n    addStore(id, name, store, options) {\n      let storeName = name;\n      const names = Object.values(this.#stores).map(store => store.name);\n      if (names.includes(storeName)) {\n        // const { options } = throwIfNull(\n        //   Object.values(this.#stores).find((store) => store.name === storeName)\n        // );\n        if (!options.indexNames) {\n          throw new Error(`An instance of the store ${storeName} already exists. \\\nEnable automatic indexing via withDevTools('${storeName}', { indexNames: true }), or rename it upon instantiation.`);\n        }\n      }\n      for (let i = 1; names.includes(storeName); i++) {\n        storeName = `${name}-${i}`;\n      }\n      this.#stores[id] = {\n        name: storeName,\n        options\n      };\n      const tracker = options.tracker;\n      if (!this.#trackers.includes(tracker)) {\n        this.#trackers.push(tracker);\n      }\n      tracker.onChange(changedState => this.syncToDevTools(changedState));\n      tracker.track(id, store);\n    }\n    removeStore(id) {\n      const name = this.#stores[id].name;\n      this.#stores = Object.entries(this.#stores).reduce((newStore, [storeId, value]) => {\n        if (storeId !== id) {\n          newStore[storeId] = value;\n        }\n        return newStore;\n      }, {});\n      this.#currentState = Object.entries(this.#currentState).reduce((newState, [storeName, state]) => {\n        if (storeName !== name) {\n          newState[storeName] = state;\n        }\n        return newState;\n      }, {});\n      for (const tracker of this.#trackers) {\n        tracker.removeStore(id);\n      }\n    }\n    /**\n     * Renames a store identified by its internal id. If the store has already\n     * been removed (e.g. due to component destruction), this is a no-op.\n     */\n    renameStore(id, newName) {\n      const storeEntry = this.#stores[id];\n      if (!storeEntry) {\n        return;\n      }\n      const oldName = storeEntry.name;\n      if (oldName === newName) {\n        return;\n      }\n      const otherStoreNames = Object.entries(this.#stores).filter(([entryId]) => entryId !== id).map(([, s]) => s.name);\n      if (otherStoreNames.includes(newName)) {\n        throw new Error(`NgRx Toolkit/DevTools: cannot rename from ${oldName} to ${newName}. ${newName} is already assigned to another SignalStore instance.`);\n      }\n      this.#stores = Object.entries(this.#stores).reduce((newStore, [entryId, value]) => {\n        if (entryId === id) {\n          newStore[entryId] = {\n            ...value,\n            name: newName\n          };\n        } else {\n          newStore[entryId] = value;\n        }\n        return newStore;\n      }, {});\n      // we don't rename in #currentState but wait for tracker to notify\n      // us with a changed state that contains that name.\n      this.#currentState = Object.entries(this.#currentState).reduce((newState, [storeName, state]) => {\n        if (storeName !== oldName) {\n          newState[storeName] = state;\n        }\n        return newState;\n      }, {});\n      this.#trackers.forEach(tracker => tracker.notifyRenamedStore(id));\n    }\n    static {\n      this.Éµfac = function DevtoolsSyncer_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || DevtoolsSyncer)();\n      };\n    }\n    static {\n      this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: DevtoolsSyncer,\n        factory: DevtoolsSyncer.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return DevtoolsSyncer;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst renameDevtoolsMethodName = '___renameDevtoolsName';\nconst uniqueDevtoolsId = '___uniqueDevtoolsId';\nconst EXISTING_NAMES = new InjectionToken('Array contain existing names for the signal stores', {\n  factory: () => [],\n  providedIn: 'root'\n});\n/**\n * Adds this store as a feature state to the Redux DevTools.\n *\n * By default, the action name is 'Store Update'. You can\n * change that via the {@link updateState} method, which has as second\n * parameter the action name.\n *\n * The standalone function {@link renameDevtoolsName} can rename\n * the store name.\n *\n * @param name name of the store as it should appear in the DevTools\n * @param features features to extend or modify the behavior of the Devtools\n */\nfunction withDevtools(name, ...features) {\n  return signalStoreFeature(withMethods(() => {\n    const syncer = inject(DevtoolsSyncer);\n    const id = syncer.getNextId();\n    // TODO: use withProps and symbols\n    return {\n      [renameDevtoolsMethodName]: newName => {\n        syncer.renameStore(id, newName);\n      },\n      [uniqueDevtoolsId]: () => id\n    };\n  }), withHooks(store => {\n    const syncer = inject(DevtoolsSyncer);\n    const id = String(store[uniqueDevtoolsId]());\n    return {\n      onInit() {\n        const id = String(store[uniqueDevtoolsId]());\n        const finalOptions = {\n          indexNames: !features.some(f => f.indexNames === false),\n          map: features.find(f => f.map)?.map ?? (state => state),\n          tracker: inject(features.find(f => f.tracker)?.tracker || DefaultTracker)\n        };\n        syncer.addStore(id, name, store, finalOptions);\n      },\n      onDestroy() {\n        syncer.removeStore(id);\n      }\n    };\n  }));\n}\n\n/**\n * Renames the name of a store how it appears in the Devtools.\n * @param store instance of the SignalStore\n * @param newName new name for the Devtools\n */\nfunction renameDevtoolsName(store, newName) {\n  const renameMethod = store[renameDevtoolsMethodName];\n  if (!renameMethod) {\n    throw new Error(\"Devtools extensions haven't been added to this store.\");\n  }\n  renameMethod(newName);\n}\n\n/**\n * @deprecated Has been renamed to `updateState`\n */\nconst patchState = (state, action, ...rest) => {\n  updateState(state, action, ...rest);\n};\n/**\n * Wrapper of `patchState` for DevTools integration. Next to updating the state,\n * it also sends the action to the DevTools.\n * @param stateSource state of Signal Store\n * @param action name of action how it will show in DevTools\n * @param updaters updater functions or objects\n */\nfunction updateState(stateSource, action, ...updaters) {\n  currentActionNames.add(action);\n  return patchState$1(stateSource, ...updaters);\n}\n\n/**\n * Stub for DevTools integration. Can be used to disable DevTools in production.\n */\nconst withDevToolsStub = () => store => store;\nfunction assertActionFnSpecs(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new Error('%o is not an Action Specification');\n  }\n}\nfunction payload() {\n  return {};\n}\nconst noPayload = {};\n/**\n * Creates a reducer function to separate the reducer logic into another file.\n *\n * ```typescript\n * interface FlightState {\n *   flights: Flight[];\n *   effect1: boolean;\n *   effect2: boolean;\n * }\n *\n * const initialState: FlightState = {\n *   flights: [],\n *   effect1: false,\n *   effect2: false,\n * };\n *\n * const actions = {\n *   init: noPayload,\n *   updateEffect1: payload<{ value: boolean }>(),\n *   updateEffect2: payload<{ value: boolean }>(),\n * };\n *\n * const reducer = createReducer<FlightState, typeof actions>((actions, on) => {\n *   on(actions.updateEffect1, (state, { value }) => {\n *     patchState(state, { effect1: value });\n *   });\n *\n *   on(actions.updateEffect2, (state, { value }) => {\n *     patchState(state, { effect2: value });\n *   });\n * });\n *\n * signalStore(\n *   withState(initialState),\n *   withRedux({\n *     actions,\n *     reducer,\n *   })\n * );\n * ```\n * @param reducerFactory\n */\nfunction createReducer(reducerFactory) {\n  return reducerFactory;\n}\n/**\n * @deprecated Use NgRx's `@ngrx/signals/events` starting in 19.2\n *\n * Creates the effects function to separate the effects logic into another file.\n *\n * ```typescript\n * interface FlightState {\n *   flights: Flight[];\n *   effect1: boolean;\n *   effect2: boolean;\n * }\n *\n * const initialState: FlightState = {\n *   flights: [],\n *   effect1: false,\n *   effect2: false,\n * };\n *\n * const actions = {\n *   init: noPayload,\n *   updateEffect1: payload<{ value: boolean }>(),\n *   updateEffect2: payload<{ value: boolean }>(),\n * };\n *\n * const effects = createEffects(actions, (actions, create) => {\n *   return {\n *     init1$: create(actions.init).pipe(\n *       map(() => actions.updateEffect1({ value: true }))\n *     ),\n *     init2$: create(actions.init).pipe(\n *       map(() => actions.updateEffect2({ value: true }))\n *     ),\n *   };\n * });\n *\n * signalStore(\n *   withState(initialState),\n *   withRedux({\n *     actions,\n *     effects,\n *   })\n * );\n * ```\n * @param actions\n * @param effectsFactory\n */\nfunction createEffects(actions, effectsFactory) {\n  return effectsFactory;\n}\nfunction createActionFns(actionFnSpecs, reducerRegistry, effectsRegistry, state) {\n  const actionFns = {};\n  for (const type in actionFnSpecs) {\n    const actionFn = payload => {\n      const fullPayload = {\n        ...payload,\n        type\n      };\n      const reducer = reducerRegistry[type];\n      if (reducer) {\n        reducer(state, fullPayload);\n      }\n      const effectSubjects = effectsRegistry[type];\n      if (effectSubjects?.length) {\n        for (const effectSubject of effectSubjects) {\n          effectSubject.next(fullPayload);\n        }\n      }\n      return fullPayload;\n    };\n    actionFn.type = type.toString();\n    actionFns[type] = actionFn;\n  }\n  return actionFns;\n}\nfunction createPublicAndAllActionsFns(actionFnSpecs, reducerRegistry, effectsRegistry, state) {\n  if ('public' in actionFnSpecs || 'private' in actionFnSpecs) {\n    const privates = actionFnSpecs['private'] || {};\n    const publics = actionFnSpecs['public'] || {};\n    assertActionFnSpecs(privates);\n    assertActionFnSpecs(publics);\n    const privateActionFns = createActionFns(privates, reducerRegistry, effectsRegistry, state);\n    const publicActionFns = createActionFns(publics, reducerRegistry, effectsRegistry, state);\n    return {\n      all: {\n        ...privateActionFns,\n        ...publicActionFns\n      },\n      publics: publicActionFns\n    };\n  }\n  const actionFns = createActionFns(actionFnSpecs, reducerRegistry, effectsRegistry, state);\n  return {\n    all: actionFns,\n    publics: actionFns\n  };\n}\nfunction fillReducerRegistry(reducer, actionFns, reducerRegistry) {\n  function on(action, reducerFn) {\n    reducerRegistry[action.type] = reducerFn;\n  }\n  reducer(actionFns, on);\n  return reducerRegistry;\n}\nfunction fillEffects(effects, actionFns, effectsRegistry = {}) {\n  function create(action) {\n    const subject = new Subject();\n    if (!(action.type in effectsRegistry)) {\n      effectsRegistry[action.type] = [];\n    }\n    effectsRegistry[action.type].push(subject);\n    return subject.asObservable();\n  }\n  const effectObservables = effects(actionFns, create);\n  return Object.values(effectObservables);\n}\nfunction startSubscriptions(observables) {\n  return observables.map(observable => observable.subscribe());\n}\nfunction processRedux(actionFnSpecs, reducer, effects, store) {\n  const reducerRegistry = {};\n  const effectsRegistry = {};\n  const actionsMap = createPublicAndAllActionsFns(actionFnSpecs, reducerRegistry, effectsRegistry, store);\n  const actionFns = actionsMap.all;\n  const publicActionsFns = actionsMap.publics;\n  fillReducerRegistry(reducer, actionFns, reducerRegistry);\n  const effectObservables = fillEffects(effects, actionFns, effectsRegistry);\n  const subscriptions = startSubscriptions(effectObservables);\n  return {\n    methods: publicActionsFns,\n    subscriptions: subscriptions\n  };\n}\n/**\n * @param redux redux\n *\n * properties do not start with `with` since they are not extension functions on their own.\n *\n * no dependency to NgRx\n *\n * actions are passed to reducer and effects, but it is also possible to use other actions.\n * effects provide forAction and do not return anything. that is important because effects should stay inaccessible\n */\nfunction withRedux(redux) {\n  return store => {\n    const {\n      methods\n    } = processRedux(redux.actions, redux.reducer, redux.effects, store);\n    return {\n      ...store,\n      methods: {\n        ...store.methods,\n        ...methods\n      }\n    };\n  };\n}\nfunction deriveCallStateKeys(collection) {\n  return {\n    callStateKey: collection ? `${collection}CallState` : 'callState',\n    loadingKey: collection ? `${collection}Loading` : 'loading',\n    loadedKey: collection ? `${collection}Loaded` : 'loaded',\n    errorKey: collection ? `${collection}Error` : 'error'\n  };\n}\nfunction getCallStateKeys(config) {\n  const prop = config?.collection;\n  return deriveCallStateKeys(prop);\n}\nfunction getCollectionArray(config) {\n  return 'collections' in config ? config.collections : 'collection' in config && config.collection ? [config.collection] : undefined;\n}\nfunction withCallState(config) {\n  return signalStoreFeature(withState(() => {\n    if (!config) {\n      return {\n        callState: 'init'\n      };\n    }\n    const collections = getCollectionArray(config);\n    if (collections) {\n      return collections.reduce((acc, cur) => ({\n        ...acc,\n        ...{\n          [cur ? `${cur}CallState` : 'callState']: 'init'\n        }\n      }), {});\n    }\n    return {\n      callState: 'init'\n    };\n  }), withComputed(state => {\n    if (config) {\n      const collections = getCollectionArray(config);\n      if (collections) {\n        return collections.reduce((acc, cur) => {\n          const {\n            callStateKey,\n            errorKey,\n            loadedKey,\n            loadingKey\n          } = deriveCallStateKeys(cur);\n          const callState = state[callStateKey];\n          return {\n            ...acc,\n            [loadingKey]: computed(() => callState() === 'loading'),\n            [loadedKey]: computed(() => callState() === 'loaded'),\n            [errorKey]: computed(() => {\n              const v = callState();\n              return typeof v === 'object' ? v.error : null;\n            })\n          };\n        }, {});\n      }\n    }\n    const {\n      callStateKey,\n      errorKey,\n      loadedKey,\n      loadingKey\n    } = deriveCallStateKeys();\n    const callState = state[callStateKey];\n    return {\n      [loadingKey]: computed(() => callState() === 'loading'),\n      [loadedKey]: computed(() => callState() === 'loaded'),\n      [errorKey]: computed(() => {\n        const v = callState();\n        return typeof v === 'object' ? v.error : null;\n      })\n    };\n  }));\n}\nfunction setLoading(prop) {\n  if (prop) {\n    return {\n      [`${prop}CallState`]: 'loading'\n    };\n  }\n  return {\n    callState: 'loading'\n  };\n}\nfunction setLoaded(prop) {\n  if (prop) {\n    return {\n      [`${prop}CallState`]: 'loaded'\n    };\n  } else {\n    return {\n      callState: 'loaded'\n    };\n  }\n}\nfunction setError(error, prop) {\n  let errorMessage;\n  if (!error) {\n    errorMessage = '';\n  } else if (typeof error === 'object' && 'message' in error) {\n    errorMessage = String(error.message);\n  } else {\n    errorMessage = String(error);\n  }\n  if (prop) {\n    return {\n      [`${prop}CallState`]: {\n        error: errorMessage\n      }\n    };\n  } else {\n    return {\n      callState: {\n        error: errorMessage\n      }\n    };\n  }\n}\nfunction capitalize(str) {\n  return str ? str[0].toUpperCase() + str.substring(1) : str;\n}\nfunction getDataServiceKeys(options) {\n  const filterKey = options.collection ? `${options.collection}Filter` : 'filter';\n  const selectedIdsKey = options.collection ? `selected${capitalize(options.collection)}Ids` : 'selectedIds';\n  const selectedEntitiesKey = options.collection ? `selected${capitalize(options.collection)}Entities` : 'selectedEntities';\n  const updateFilterKey = options.collection ? `update${capitalize(options.collection)}Filter` : 'updateFilter';\n  const updateSelectedKey = options.collection ? `updateSelected${capitalize(options.collection)}Entities` : 'updateSelected';\n  const loadKey = options.collection ? `load${capitalize(options.collection)}Entities` : 'load';\n  const currentKey = options.collection ? `current${capitalize(options.collection)}` : 'current';\n  const loadByIdKey = options.collection ? `load${capitalize(options.collection)}ById` : 'loadById';\n  const setCurrentKey = options.collection ? `setCurrent${capitalize(options.collection)}` : 'setCurrent';\n  const createKey = options.collection ? `create${capitalize(options.collection)}` : 'create';\n  const updateKey = options.collection ? `update${capitalize(options.collection)}` : 'update';\n  const updateAllKey = options.collection ? `updateAll${capitalize(options.collection)}` : 'updateAll';\n  const deleteKey = options.collection ? `delete${capitalize(options.collection)}` : 'delete';\n  // TODO: Take these from @ngrx/signals/entities, when they are exported\n  const entitiesKey = options.collection ? `${options.collection}Entities` : 'entities';\n  const entityMapKey = options.collection ? `${options.collection}EntityMap` : 'entityMap';\n  const idsKey = options.collection ? `${options.collection}Ids` : 'ids';\n  return {\n    filterKey,\n    selectedIdsKey,\n    selectedEntitiesKey,\n    updateFilterKey,\n    updateSelectedKey,\n    loadKey,\n    entitiesKey,\n    entityMapKey,\n    idsKey,\n    currentKey,\n    loadByIdKey,\n    setCurrentKey,\n    createKey,\n    updateKey,\n    updateAllKey,\n    deleteKey\n  };\n}\nfunction withDataService(options) {\n  const {\n    dataServiceType,\n    filter,\n    collection: prefix\n  } = options;\n  const {\n    entitiesKey,\n    filterKey,\n    loadKey,\n    selectedEntitiesKey,\n    selectedIdsKey,\n    updateFilterKey,\n    updateSelectedKey,\n    currentKey,\n    createKey,\n    updateKey,\n    updateAllKey,\n    deleteKey,\n    loadByIdKey,\n    setCurrentKey\n  } = getDataServiceKeys(options);\n  const {\n    callStateKey\n  } = getCallStateKeys({\n    collection: prefix\n  });\n  return signalStoreFeature(withState(() => ({\n    [filterKey]: filter,\n    [selectedIdsKey]: {},\n    [currentKey]: undefined\n  })), withComputed(store => {\n    const entities = store[entitiesKey];\n    const selectedIds = store[selectedIdsKey];\n    return {\n      [selectedEntitiesKey]: computed(() => entities().filter(e => selectedIds()[e.id]))\n    };\n  }), withMethods(store => {\n    const dataService = inject(dataServiceType);\n    return {\n      [updateFilterKey]: filter => {\n        patchState$1(store, {\n          [filterKey]: filter\n        });\n      },\n      [updateSelectedKey]: (id, selected) => {\n        patchState$1(store, state => ({\n          [selectedIdsKey]: {\n            ...state[selectedIdsKey],\n            [id]: selected\n          }\n        }));\n      },\n      [loadKey]: async () => {\n        const filter = store[filterKey];\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const result = await dataService.load(filter());\n          patchState$1(store, prefix ? setAllEntities(result, {\n            collection: prefix\n          }) : setAllEntities(result));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [loadByIdKey]: async id => {\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const current = await dataService.loadById(id);\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n          patchState$1(store, {\n            [currentKey]: current\n          });\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [setCurrentKey]: current => {\n        patchState$1(store, {\n          [currentKey]: current\n        });\n      },\n      [createKey]: async entity => {\n        patchState$1(store, {\n          [currentKey]: entity\n        });\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const created = await dataService.create(entity);\n          patchState$1(store, {\n            [currentKey]: created\n          });\n          patchState$1(store, prefix ? addEntity(created, {\n            collection: prefix\n          }) : addEntity(created));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [updateKey]: async entity => {\n        patchState$1(store, {\n          [currentKey]: entity\n        });\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const updated = await dataService.update(entity);\n          patchState$1(store, {\n            [currentKey]: updated\n          });\n          const updateArg = {\n            id: updated.id,\n            changes: updated\n          };\n          const updater = collection => updateEntity(updateArg, {\n            collection\n          });\n          patchState$1(store, prefix ? updater(prefix) : updateEntity(updateArg));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [updateAllKey]: async entities => {\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          const result = await dataService.updateAll(entities);\n          patchState$1(store, prefix ? setAllEntities(result, {\n            collection: prefix\n          }) : setAllEntities(result));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      },\n      [deleteKey]: async entity => {\n        patchState$1(store, {\n          [currentKey]: entity\n        });\n        (() => store[callStateKey] && patchState$1(store, setLoading(prefix)))();\n        try {\n          await dataService.delete(entity);\n          patchState$1(store, {\n            [currentKey]: undefined\n          });\n          patchState$1(store, prefix ? removeEntity(entity.id, {\n            collection: prefix\n          }) : removeEntity(entity.id));\n          (() => store[callStateKey] && patchState$1(store, setLoaded(prefix)))();\n        } catch (e) {\n          (() => store[callStateKey] && patchState$1(store, setError(e, prefix)))();\n          throw e;\n        }\n      }\n    };\n  }));\n}\n\n/** With pagination comes in two flavors the first one is local pagination or in memory pagination. For example we have 2000 items which we want\n * to display in a table and the response payload is small enough to be stored in the memory. But we can not display all 2000 items at once\n * so we need to paginate the data. The second flavor is server side pagination where the response payload is too large to be stored in the memory\n * and we need to fetch the data from the server in chunks. In the second case we 'could' also cache the data in the memory but that could lead to\n * other problems like memory leaks and stale data. So we will not cache the data in the memory in the second case.\n * This feature implements the local pagination.\n */\nfunction withPagination(options) {\n  const {\n    pageKey,\n    pageSizeKey,\n    entitiesKey,\n    selectedPageEntitiesKey,\n    totalCountKey,\n    pageCountKey,\n    pageNavigationArrayMaxKey,\n    pageNavigationArrayKey,\n    hasNextPageKey,\n    hasPreviousPageKey\n  } = createPaginationKeys(options);\n  return signalStoreFeature(withState({\n    [pageKey]: 0,\n    [pageSizeKey]: 10,\n    [pageNavigationArrayMaxKey]: 7\n  }), withComputed(store => {\n    const entities = store[entitiesKey];\n    const page = store[pageKey];\n    const pageSize = store[pageSizeKey];\n    const pageNavigationArrayMax = store[pageNavigationArrayMaxKey];\n    return {\n      // The derived enitites which are displayed on the current page\n      [selectedPageEntitiesKey]: computed(() => {\n        const pageSizeValue = pageSize();\n        const pageValue = page();\n        return entities().slice(pageValue * pageSizeValue, (pageValue + 1) * pageSizeValue);\n      }),\n      [totalCountKey]: computed(() => entities().length),\n      [pageCountKey]: computed(() => {\n        const totalCountValue = entities().length;\n        const pageSizeValue = pageSize();\n        if (totalCountValue === 0) {\n          return 0;\n        }\n        return Math.ceil(totalCountValue / pageSizeValue);\n      }),\n      [pageNavigationArrayKey]: computed(() => createPageArray(page(), pageSize(), entities().length, pageNavigationArrayMax())),\n      [hasNextPageKey]: computed(() => {\n        return page() < pageSize();\n      }),\n      [hasPreviousPageKey]: computed(() => {\n        return page() > 1;\n      })\n    };\n  }));\n}\nfunction gotoPage(page, options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return {\n    [pageKey]: page\n  };\n}\nfunction setPageSize(pageSize, options) {\n  const {\n    pageSizeKey\n  } = createPaginationKeys(options);\n  return {\n    [pageSizeKey]: pageSize\n  };\n}\nfunction nextPage(options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return state => {\n    const currentPage = state[pageKey];\n    return {\n      [pageKey]: currentPage + 1\n    };\n  };\n}\nfunction previousPage(options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return state => {\n    const currentPage = state[pageKey];\n    return {\n      [pageKey]: currentPage - 1\n    };\n  };\n}\nfunction firstPage(options) {\n  const {\n    pageKey\n  } = createPaginationKeys(options);\n  return {\n    [pageKey]: 0\n  };\n}\nfunction setMaxPageNavigationArrayItems(maxPageNavigationArrayItems, options) {\n  const {\n    pageNavigationArrayMaxKey\n  } = createPaginationKeys(options);\n  return {\n    [pageNavigationArrayMaxKey]: maxPageNavigationArrayItems\n  };\n}\nfunction createPaginationKeys(options) {\n  const entitiesKey = options?.collection ? `${options.collection}Entities` : 'entities';\n  const selectedPageEntitiesKey = options?.collection ? `selectedPage${capitalize(options?.collection)}Entities` : 'selectedPageEntities';\n  const pageKey = options?.collection ? `${options.collection}CurrentPage` : 'currentPage';\n  const pageSizeKey = options?.collection ? `${options.collection}PageSize` : 'pageSize';\n  const totalCountKey = options?.collection ? `${options.collection}TotalCount` : 'totalCount';\n  const pageCountKey = options?.collection ? `${options.collection}PageCount` : 'pageCount';\n  const pageNavigationArrayMaxKey = options?.collection ? `${options.collection}PageNavigationArrayMax` : 'pageNavigationArrayMax';\n  const pageNavigationArrayKey = options?.collection ? `${options.collection}PageNavigationArray` : 'pageNavigationArray';\n  const hasNextPageKey = options?.collection ? `hasNext${capitalize(options.collection)}Page` : 'hasNextPage';\n  const hasPreviousPageKey = options?.collection ? `hasPrevious${capitalize(options.collection)}Page` : 'hasPreviousPage';\n  return {\n    pageKey,\n    pageSizeKey,\n    entitiesKey,\n    selectedPageEntitiesKey,\n    totalCountKey,\n    pageCountKey,\n    pageNavigationArrayKey,\n    pageNavigationArrayMaxKey,\n    hasNextPageKey,\n    hasPreviousPageKey\n  };\n}\nfunction createPageArray(currentPage, itemsPerPage, totalItems, paginationRange) {\n  // Convert paginationRange to number in case it's a string\n  paginationRange = +paginationRange;\n  // Calculate total number of pages\n  const totalPages = Math.max(Math.ceil(totalItems / itemsPerPage), 1);\n  const halfWay = Math.ceil(paginationRange / 2);\n  const isStart = currentPage <= halfWay;\n  const isEnd = totalPages - halfWay < currentPage;\n  const isMiddle = !isStart && !isEnd;\n  const ellipsesNeeded = paginationRange < totalPages;\n  const pages = [];\n  for (let i = 1; i <= totalPages && i <= paginationRange; i++) {\n    let pageNumber = i;\n    if (i === paginationRange) {\n      pageNumber = totalPages;\n    } else if (ellipsesNeeded) {\n      if (isEnd) {\n        pageNumber = totalPages - paginationRange + i;\n      } else if (isMiddle) {\n        pageNumber = currentPage - halfWay + i;\n      }\n    }\n    const openingEllipsesNeeded = i === 2 && (isMiddle || isEnd);\n    const closingEllipsesNeeded = i === paginationRange - 1 && (isMiddle || isStart);\n    const label = ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded) ? '...' : pageNumber;\n    pages.push({\n      label,\n      value: pageNumber\n    });\n  }\n  return pages;\n}\n\n/**\n * Adds a `resetState` method to the store, which resets the state\n * to the initial state.\n *\n * If you want to set a custom initial state, you can use {@link setResetState}.\n */\nfunction withReset() {\n  return signalStoreFeature(withProps(() => ({\n    _resetState: {\n      value: {}\n    }\n  })), withMethods(store => {\n    // workaround to TS excessive property check\n    const methods = {\n      resetState() {\n        patchState$1(store, store._resetState.value);\n      },\n      __setResetState__(state) {\n        store._resetState.value = state;\n      }\n    };\n    return methods;\n  }), withHooks(store => ({\n    onInit() {\n      store._resetState.value = getState(store);\n    }\n  })));\n}\n/**\n * Sets the reset state of the store to the given state.\n *\n * Throws an error if the store is not configured with {@link withReset}.\n * @param store the instance of a SignalStore\n * @param state the state to set as the reset state\n */\nfunction setResetState(store, state) {\n  if (!('__setResetState__' in store)) {\n    throw new Error('Cannot set reset state, since store is not configured with withReset()');\n  }\n  store.__setResetState__(state);\n}\nconst defaultOptions = {\n  maxStackSize: 100,\n  keys: [],\n  skip: 0\n};\nfunction getUndoRedoKeys(collections) {\n  if (collections) {\n    return collections.flatMap(c => [`${c}EntityMap`, `${c}Ids`, `selected${capitalize(c)}Ids`, `${c}Filter`]);\n  }\n  return ['entityMap', 'ids', 'selectedIds', 'filter'];\n}\nfunction withUndoRedo(options) {\n  let previous = null;\n  let skipOnce = false;\n  const normalized = {\n    ...defaultOptions,\n    ...options\n  };\n  //\n  // Design Decision: This feature has its own\n  // internal state.\n  //\n  const undoStack = [];\n  const redoStack = [];\n  const canUndo = signal(false, ...(ngDevMode ? [{\n    debugName: \"canUndo\"\n  }] : []));\n  const canRedo = signal(false, ...(ngDevMode ? [{\n    debugName: \"canRedo\"\n  }] : []));\n  const updateInternal = () => {\n    canUndo.set(undoStack.length !== 0);\n    canRedo.set(redoStack.length !== 0);\n  };\n  const keys = [...getUndoRedoKeys(normalized.collections), ...normalized.keys];\n  return signalStoreFeature(withComputed(() => ({\n    canUndo: canUndo.asReadonly(),\n    canRedo: canRedo.asReadonly()\n  })), withMethods(store => ({\n    undo() {\n      const item = undoStack.pop();\n      if (item && previous) {\n        redoStack.push(previous);\n      }\n      if (item) {\n        skipOnce = true;\n        patchState$1(store, item);\n        previous = item;\n      }\n      updateInternal();\n    },\n    redo() {\n      const item = redoStack.pop();\n      if (item && previous) {\n        undoStack.push(previous);\n      }\n      if (item) {\n        skipOnce = true;\n        patchState$1(store, item);\n        previous = item;\n      }\n      updateInternal();\n    },\n    clearStack() {\n      undoStack.splice(0);\n      redoStack.splice(0);\n      previous = null;\n      updateInternal();\n    }\n  })), withHooks({\n    onInit(store) {\n      watchState(store, () => {\n        const cand = keys.reduce((acc, key) => {\n          const s = store[key];\n          if (s && isSignal(s)) {\n            return {\n              ...acc,\n              [key]: s()\n            };\n          }\n          return acc;\n        }, {});\n        if (normalized.skip > 0) {\n          normalized.skip--;\n          return;\n        }\n        if (skipOnce) {\n          skipOnce = false;\n          return;\n        }\n        //\n        // Deep Comparison to prevent duplicated entries\n        // on the stack. This can e.g. happen after an undo\n        // if the component sends back the undone filter\n        // to the store.\n        //\n        if (JSON.stringify(cand) === JSON.stringify(previous)) {\n          return;\n        }\n        // Clear redoStack after recorded action\n        redoStack.splice(0);\n        if (previous) {\n          undoStack.push(previous);\n        }\n        if (redoStack.length > normalized.maxStackSize) {\n          undoStack.unshift();\n        }\n        previous = cand;\n        // Don't propogate current reactive context\n        untracked(() => updateInternal());\n      });\n    }\n  }));\n}\n\n/**\n * Deep freezes a state object along its properties with primitive values\n * on the first level.\n *\n * The reason for this is that the final state is a merge of all\n * root properties of all states, i.e. `withState`,....\n *\n * Since the root object will not be part of the state (shadow clone),\n * we are not freezing it.\n */\nfunction deepFreeze(target,\n// if empty all properties will be frozen\npropertyNamesToBeFrozen,\n// also means that we are on the first level\nisRoot = true) {\n  const runPropertyNameCheck = propertyNamesToBeFrozen.length > 0;\n  for (const key of Reflect.ownKeys(target)) {\n    if (runPropertyNameCheck && !propertyNamesToBeFrozen.includes(key)) {\n      continue;\n    }\n    const propValue = target[key];\n    if (isRecordLike(propValue) && !Object.isFrozen(propValue)) {\n      Object.freeze(propValue);\n      deepFreeze(propValue, [], false);\n    } else if (isRoot) {\n      Object.defineProperty(target, key, {\n        value: propValue,\n        writable: false,\n        configurable: false\n      });\n    }\n  }\n}\nfunction isRecordLike(target) {\n  return typeof target === 'object' && target !== null;\n}\n\n// necessary wrapper function to test prod mode\nfunction isDevMode() {\n  return isDevMode$1();\n}\nfunction withImmutableState(stateOrFactory, options) {\n  const immutableState = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n  const stateKeys = Reflect.ownKeys(immutableState);\n  const applyFreezing = isDevMode() || options?.enableInProduction === true;\n  return signalStoreFeature(withState(immutableState), withHooks(store => ({\n    onInit() {\n      if (!applyFreezing) {\n        return;\n      }\n      /**\n       * `immutableState` will be initially frozen. That is because\n       * of potential mutations outside the SignalStore\n       *\n       * ```ts\n       * const initialState = {user: {id: 1}};\n       * signalStore(withImmutableState(initialState));\n       *\n       * initialState.user.id = 2; // must throw immutability\n       * ```\n       */\n      deepFreeze(getState(store), stateKeys);\n      watchState(store, state => {\n        deepFreeze(state, stateKeys);\n      });\n    }\n  })));\n}\nconst keyPath = 'ngrxToolkitKeyPath';\nconst dbName = 'ngrxToolkitDb';\nconst storeName = 'ngrxToolkitStore';\nconst VERSION = 1;\nlet IndexedDBService = /*#__PURE__*/(() => {\n  class IndexedDBService {\n    /**\n     * write to indexedDB\n     * @param key\n     * @param data\n     */\n    async setItem(key, data) {\n      const db = await this.openDB();\n      const tx = db.transaction(storeName, 'readwrite');\n      const store = tx.objectStore(storeName);\n      store.put({\n        [keyPath]: key,\n        value: data\n      });\n      return new Promise((resolve, reject) => {\n        tx.oncomplete = () => {\n          db.close();\n          resolve();\n        };\n        tx.onerror = () => {\n          db.close();\n          reject();\n        };\n      });\n    }\n    /**\n     * read from indexedDB\n     * @param key\n     */\n    async getItem(key) {\n      const db = await this.openDB();\n      const tx = db.transaction(storeName, 'readonly');\n      const store = tx.objectStore(storeName);\n      const request = store.get(key);\n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          db.close();\n          // localStorage(sessionStorage) returns null if the key does not exist\n          // Similarly, indexedDB should return null\n          if (request.result === undefined) {\n            resolve(null);\n          }\n          resolve(request.result?.['value']);\n        };\n        request.onerror = () => {\n          db.close();\n          reject();\n        };\n      });\n    }\n    /**\n     * delete indexedDB\n     * @param key\n     */\n    async clear(key) {\n      const db = await this.openDB();\n      const tx = db.transaction(storeName, 'readwrite');\n      const store = tx.objectStore(storeName);\n      const request = store.delete(key);\n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          db.close();\n          resolve();\n        };\n        request.onerror = () => {\n          db.close();\n          reject();\n        };\n      });\n    }\n    /**\n     * open indexedDB\n     */\n    async openDB() {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, VERSION);\n        request.onupgradeneeded = () => {\n          const db = request.result;\n          if (!db.objectStoreNames.contains(storeName)) {\n            db.createObjectStore(storeName, {\n              keyPath\n            });\n          }\n        };\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    }\n    static {\n      this.Éµfac = function IndexedDBService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || IndexedDBService)();\n      };\n    }\n    static {\n      this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: IndexedDBService,\n        factory: IndexedDBService.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return IndexedDBService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * AsyncFeatureResult is used as the public interface that users interact with\n * when calling `withIndexedDB`. It intentionally omits the internal SYNC_STATUS\n * property to avoid TypeScript error TS4058 (return type of public method\n * includes private type).\n *\n * For internal implementation, we use AsyncStoreForFactory which includes\n * the SYNC_STATUS property needed for state management.\n */\nconst SYNC_STATUS = Symbol('SYNC_STATUS');\nfunction withIndexedDB() {\n  function factory({\n    key,\n    parse,\n    select,\n    stringify\n  }, store, useStubs) {\n    if (useStubs) {\n      return {\n        clearStorage: () => Promise.resolve(),\n        readFromStorage: () => Promise.resolve(),\n        writeToStorage: () => Promise.resolve()\n      };\n    }\n    const indexeddbService = inject(IndexedDBService);\n    function warnOnSyncing(mode) {\n      if (store[SYNC_STATUS]() === 'syncing') {\n        const prettyMode = mode === 'read' ? 'Reading' : 'Writing';\n        console.warn(`${prettyMode} to Store (${key}) happened during an ongoing synchronization process.`, 'Please ensure that the store is not in syncing state via `store.whenSynced()`.', 'Alternatively, you can disable the autoSync by passing `autoSync: false` in the config.');\n      }\n    }\n    return {\n      /**\n       * Removes the item stored in storage.\n       */\n      async clearStorage() {\n        warnOnSyncing('write');\n        store[SYNC_STATUS].set('syncing');\n        patchState$1(store, {});\n        await indexeddbService.clear(key);\n        store[SYNC_STATUS].set('synced');\n      },\n      /**\n       * Reads item from storage and patches the state.\n       */\n      async readFromStorage() {\n        warnOnSyncing('read');\n        store[SYNC_STATUS].set('syncing');\n        const stateString = await indexeddbService.getItem(key);\n        if (stateString) {\n          patchState$1(store, parse(stateString));\n        }\n        store[SYNC_STATUS].set('synced');\n      },\n      /**\n       * Writes selected portion to storage.\n       */\n      async writeToStorage() {\n        warnOnSyncing('write');\n        store[SYNC_STATUS].set('syncing');\n        const slicedState = select(getState(store));\n        await indexeddbService.setItem(key, stringify(slicedState));\n        store[SYNC_STATUS].set('synced');\n      }\n    };\n  }\n  factory.type = 'async';\n  return factory;\n}\nlet LocalStorageService = /*#__PURE__*/(() => {\n  class LocalStorageService {\n    getItem(key) {\n      return localStorage.getItem(key);\n    }\n    setItem(key, data) {\n      return localStorage.setItem(key, data);\n    }\n    clear(key) {\n      return localStorage.removeItem(key);\n    }\n    static {\n      this.Éµfac = function LocalStorageService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || LocalStorageService)();\n      };\n    }\n    static {\n      this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: LocalStorageService,\n        factory: LocalStorageService.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return LocalStorageService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SessionStorageService = /*#__PURE__*/(() => {\n  class SessionStorageService {\n    getItem(key) {\n      return sessionStorage.getItem(key);\n    }\n    setItem(key, data) {\n      return sessionStorage.setItem(key, data);\n    }\n    clear(key) {\n      return sessionStorage.removeItem(key);\n    }\n    static {\n      this.Éµfac = function SessionStorageService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || SessionStorageService)();\n      };\n    }\n    static {\n      this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: SessionStorageService,\n        factory: SessionStorageService.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return SessionStorageService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction withLocalStorage() {\n  return createSyncMethods(LocalStorageService);\n}\nfunction withSessionStorage() {\n  return createSyncMethods(SessionStorageService);\n}\nfunction createSyncMethods(Storage) {\n  function factory({\n    key,\n    parse,\n    select,\n    stringify\n  }, store, useStubs) {\n    if (useStubs) {\n      return {\n        clearStorage: () => undefined,\n        readFromStorage: () => undefined,\n        writeToStorage: () => undefined\n      };\n    }\n    const storage = inject(Storage);\n    return {\n      clearStorage() {\n        storage.clear(key);\n      },\n      readFromStorage() {\n        const stateString = storage.getItem(key);\n        if (stateString) {\n          patchState$1(store, parse(stateString));\n        }\n      },\n      writeToStorage() {\n        const slicedState = select(getState(store));\n        storage.setItem(key, stringify(slicedState));\n      }\n    };\n  }\n  factory.type = 'sync';\n  return factory;\n}\nfunction withStorageSync(configOrKey, storageStrategy) {\n  if (typeof configOrKey !== 'string' && configOrKey.storage && storageStrategy) {\n    throw new Error('You can either pass a storage strategy or a config with storage, but not both.');\n  }\n  const config = {\n    autoSync: true,\n    select: state => state,\n    parse: JSON.parse,\n    stringify: JSON.stringify,\n    storage: () => localStorage,\n    ...(typeof configOrKey === 'string' ? {\n      key: configOrKey\n    } : configOrKey)\n  };\n  const factory = storageStrategy ?? (config.storage() === localStorage ? withLocalStorage() : withSessionStorage());\n  if (factory.type === 'sync') {\n    return createSyncStorageSync(factory, config);\n  } else {\n    return createAsyncStorageSync(factory, config);\n  }\n}\nfunction createSyncStorageSync(factory, config) {\n  return signalStoreFeature(withMethods((store, platformId = inject(PLATFORM_ID)) => {\n    return factory(config, store, isPlatformServer(platformId));\n  }), withHooks({\n    onInit(store, platformId = inject(PLATFORM_ID)) {\n      if (isPlatformServer(platformId)) {\n        return;\n      }\n      if (config.autoSync) {\n        store.readFromStorage();\n        watchState(store, () => store.writeToStorage());\n      }\n    }\n  }));\n}\nfunction createAsyncStorageSync(factory, config) {\n  return signalStoreFeature(withProps(() => {\n    const props = {\n      /*\n      // we need to have that as property (and not state)\n      // Otherwise the state watcher fires when updating the sync status\n      */\n      [SYNC_STATUS]: signal('idle')\n    };\n    const resolves = [];\n    effect(() => {\n      const syncStatus = props[SYNC_STATUS]();\n      if (syncStatus === 'synced') {\n        resolves.forEach(resolve => resolve());\n        resolves.splice(0, resolves.length);\n      }\n    });\n    return {\n      ...props,\n      isSynced: computed(() => props[SYNC_STATUS]() === 'synced'),\n      whenSynced: () => new Promise(resolve => {\n        if (props[SYNC_STATUS]() === 'synced') {\n          resolve();\n        } else {\n          resolves.push(resolve);\n        }\n      })\n    };\n  }), withMethods((store, platformId = inject(PLATFORM_ID)) => {\n    return factory(config, store, isPlatformServer(platformId));\n  }), withHooks({\n    async onInit(store, platformId = inject(PLATFORM_ID)) {\n      if (isPlatformServer(platformId)) {\n        return;\n      }\n      const initialState = JSON.stringify(getState(store));\n      if (config.autoSync) {\n        let startWatching = false;\n        watchState(store, () => {\n          if (!startWatching) {\n            const currentState = JSON.stringify(getState(store));\n            // Necessary because getState returns always a new object\n            if (currentState === initialState) {\n              return;\n            }\n            console.warn(`Writing to Store (${config.key}) happened before the state was initially read from storage.`, 'Please ensure that the store is not in syncing state via `store.whenSynced()` before writing to the state.', 'Alternatively, you can disable autoSync by passing `autoSync: false` in the config.');\n            return;\n          }\n          return store.writeToStorage();\n        });\n        await store.readFromStorage();\n        startWatching = true;\n      }\n    }\n  }));\n}\n\n/**\n * `withConditional` activates a feature based on a given condition.\n *\n * **Use Cases**\n * - Conditionally activate features based on the **store state** or other criteria.\n * - Choose between **two different implementations** of a feature.\n *\n * **Type Constraints**\n * Both features must have **exactly the same state, props, and methods**.\n * Otherwise, a type error will occur.\n *\n *\n * **Usage**\n *\n * ```typescript\n * const withUser = signalStoreFeature(\n *   withState({ id: 1, name: 'Konrad' }),\n *   withHooks(store => ({\n *     onInit() {\n *       // user loading logic\n *     }\n *   }))\n * );\n *\n * function withFakeUser() {\n *   return signalStoreFeature(\n *     withState({ id: 0, name: 'anonymous' })\n *   );\n * }\n *\n * signalStore(\n *   withMethods(() => ({\n *     useRealUser: () => true\n *   })),\n *   withConditional((store) => store.useRealUser(), withUser, withFakeUser)\n * )\n * ```\n *\n * @param condition - A function that determines which feature to activate based on the store state.\n * @param featureIfTrue - The feature to activate if the condition evaluates to `true`.\n * @param featureIfFalse - The feature to activate if the condition evaluates to `false`.\n * @returns A `SignalStoreFeature` that applies the selected feature based on the condition.\n */\nfunction withConditional(condition, featureIfTrue, featureIfFalse) {\n  return store => {\n    const conditionStore = {\n      ...store['stateSignals'],\n      ...store['props'],\n      ...store['methods']\n    };\n    return condition(conditionStore) ? featureIfTrue(store) : featureIfFalse(store);\n  };\n}\nconst emptyFeature = signalStoreFeature(withState({}));\n\n/**\n * @deprecated Use `import { withFeature } from '@ngrx/signals'` instead, starting with `ngrx/signals` 19.1: https://ngrx.io/guide/signals/signal-store/custom-store-features#connecting-a-custom-feature-with-the-store\n *\n * Allows to pass properties, methods, or signals from a SignalStore\n * to a feature.\n *\n * Typically, a `signalStoreFeature` can have input constraints on\n *\n * ```typescript\n * function withSum(a: Signal<number>, b: Signal<number>) {\n *   return signalStoreFeature(\n *     withComputed(() => ({\n *       sum: computed(() => a() + b())\n *     }))\n *   );\n * }\n *\n * signalStore(\n *   withState({ a: 1, b: 2 }),\n *   withFeatureFactory((store) => withSum(store.a, store.b))\n * );\n * ```\n * @param factoryFn\n */\nfunction withFeatureFactory(factoryFn) {\n  return store => {\n    const storeForFactory = {\n      ...store['stateSignals'],\n      ...store['props'],\n      ...store['methods']\n    };\n    const feature = factoryFn(storeForFactory);\n    return feature(store);\n  };\n}\nconst switchOp = {\n  rxJsOperator: switchMap,\n  exhaustSemantics: false\n};\nconst mergeOp = {\n  rxJsOperator: mergeMap,\n  exhaustSemantics: false\n};\nconst concatOp = {\n  rxJsOperator: concatMap,\n  exhaustSemantics: false\n};\nconst exhaustOp = {\n  rxJsOperator: exhaustMap,\n  exhaustSemantics: true\n};\n\n/**\n * Creates a mutation that leverages RxJS.\n *\n * For each mutation the following options can be defined:\n * - `operation`: A function that defines the mutation logic. It returns an Observable.\n * - `onSuccess`: A callback that is called when the mutation is successful.\n * - `onError`: A callback that is called when the mutation fails.\n * - `operator`: An optional wrapper of an RxJS flattening operator. By default `concat` sematics are used.\n * - `injector`: An optional Angular injector to use for dependency injection.\n *\n * The `operation` is the only mandatory option.\n *\n * The returned mutation can be called as an async function and returns a Promise.\n * This promise informs about whether the mutation was successful, failed, or aborted\n * (due to switchMap or exhaustMap semantics).\n *\n * The mutation also provides several Signals such as error, status or isPending (see below).\n *\n * Example usage without Store:\n *\n * ```typescript\n * const counterSignal = signal(0);\n *\n * const increment = rxMutation({\n *   operation: (param: Param) => {\n *     return calcSum(this.counterSignal(), param.value);\n *   },\n *   operator: concatOp,\n *   onSuccess: (result) => {\n *     this.counterSignal.set(result);\n *   },\n *   onError: (error) => {\n *     console.error('Error occurred:', error);\n *   },\n * });\n *\n * const error = increment.error;\n * const isPending = increment.isPending;\n * const status = increment.status;\n * const value = increment.value;\n * const hasValue = increment.hasValue;\n *\n * async function incrementCounter() {\n *     const result = await increment({ value: 1 });\n *     if (result.status === 'success') {\n *       console.log('Success:', result.value);\n *     }\n *     if (result.status === 'error') {\n *       console.log('Error:', result.error);\n *     }\n *     if (result.status === 'aborted') {\n *       console.log('Operation aborted');\n *     }\n * }\n *\n * function calcSum(a: number, b: number): Observable<number> {\n *   return of(result).pipe(delay(500));\n * }\n * ```\n *\n * @param options\n * @returns the actual mutation function along tracking data as properties/methods\n */\nfunction rxMutation(optionsOrOperation) {\n  const inputSubject = new Subject();\n  const options = typeof optionsOrOperation === 'function' ? {\n    operation: optionsOrOperation\n  } : optionsOrOperation;\n  const flatteningOp = options.operator ?? concatOp;\n  const destroyRef = options.injector?.get(DestroyRef) ?? inject(DestroyRef);\n  const callCount = signal(0, ...(ngDevMode ? [{\n    debugName: \"callCount\"\n  }] : []));\n  const errorSignal = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"errorSignal\"\n  }] : []));\n  const idle = signal(true, ...(ngDevMode ? [{\n    debugName: \"idle\"\n  }] : []));\n  const isPending = computed(() => callCount() > 0, ...(ngDevMode ? [{\n    debugName: \"isPending\"\n  }] : []));\n  const value = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"value\"\n  }] : []));\n  const isSuccess = computed(() => !idle() && !isPending() && !errorSignal(), ...(ngDevMode ? [{\n    debugName: \"isSuccess\"\n  }] : []));\n  const hasValue = function () {\n    return typeof value() !== 'undefined';\n  };\n  const status = computed(() => {\n    if (idle()) {\n      return 'idle';\n    }\n    if (callCount() > 0) {\n      return 'pending';\n    }\n    if (errorSignal()) {\n      return 'error';\n    }\n    return 'success';\n  }, ...(ngDevMode ? [{\n    debugName: \"status\"\n  }] : []));\n  const initialInnerStatus = 'idle';\n  let innerStatus = initialInnerStatus;\n  inputSubject.pipe(flatteningOp.rxJsOperator(input => defer(() => {\n    callCount.update(c => c + 1);\n    idle.set(false);\n    return options.operation(input.param).pipe(tap(result => {\n      options.onSuccess?.(result, input.param);\n      innerStatus = 'success';\n      errorSignal.set(undefined);\n      value.set(result);\n    }), catchError(error => {\n      options.onError?.(error, input.param);\n      errorSignal.set(error);\n      value.set(undefined);\n      innerStatus = 'error';\n      return EMPTY;\n    }), finalize(() => {\n      callCount.update(c => c - 1);\n      if (innerStatus === 'success') {\n        input.resolve({\n          status: 'success',\n          value: value()\n        });\n      } else if (innerStatus === 'error') {\n        input.resolve({\n          status: 'error',\n          error: errorSignal()\n        });\n      } else {\n        input.resolve({\n          status: 'aborted'\n        });\n      }\n      innerStatus = initialInnerStatus;\n    }));\n  })), takeUntilDestroyed(destroyRef)).subscribe();\n  const mutationFn = param => {\n    return new Promise(resolve => {\n      if (callCount() > 0 && flatteningOp.exhaustSemantics) {\n        resolve({\n          status: 'aborted'\n        });\n      } else {\n        inputSubject.next({\n          param,\n          resolve\n        });\n      }\n    });\n  };\n  const mutation = mutationFn;\n  mutation.status = status;\n  mutation.isPending = isPending;\n  mutation.error = errorSignal;\n  mutation.value = value;\n  mutation.hasValue = hasValue;\n  mutation.isSuccess = isSuccess;\n  return mutation;\n}\nfunction withMutations(mutationsFactory) {\n  return store => {\n    // TODO: Is this the correct usage?\n    const source = store;\n    const mutations = mutationsFactory({\n      ...source,\n      ...store.props,\n      ...store.methods,\n      ...store.stateSignals\n    });\n    const feature = createMutationsFeature(mutations);\n    return feature(store);\n  };\n}\nfunction createMutationsFeature(mutations) {\n  const keys = Object.keys(mutations);\n  const feature = signalStoreFeature(withMethods(() => keys.reduce((acc, key) => ({\n    ...acc,\n    [key]: async params => {\n      const mutation = mutations[key];\n      if (!mutation) {\n        throw new Error(`Mutation ${key} not found`);\n      }\n      const result = await mutation(params);\n      return result;\n    }\n  }), {})), withComputed(() => keys.reduce((acc, key) => ({\n    ...acc,\n    [`${key}IsPending`]: mutations[key].isPending,\n    [`${key}Status`]: mutations[key].status,\n    [`${key}Error`]: mutations[key].error\n  }), {})));\n  return feature;\n}\n\n//** Types for `withResource` */\nfunction withResource(resourceFactory) {\n  return store => {\n    const resourceOrDictionary = resourceFactory({\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    if (isResourceRef(resourceOrDictionary)) {\n      return createUnnamedResource(resourceOrDictionary)(store);\n    } else {\n      return createNamedResource(resourceOrDictionary)(store);\n    }\n  };\n}\nfunction createUnnamedResource(resource) {\n  function hasValue() {\n    return resource.hasValue();\n  }\n  return signalStoreFeature(withLinkedState(() => ({\n    value: resource.value\n  })), withProps(() => ({\n    status: resource.status,\n    error: resource.error,\n    isLoading: resource.isLoading\n  })), withMethods(() => ({\n    hasValue,\n    _reload: () => resource.reload()\n  })));\n}\nfunction createNamedResource(dictionary) {\n  const keys = Object.keys(dictionary);\n  const state = keys.reduce((state, resourceName) => ({\n    ...state,\n    [`${resourceName}Value`]: dictionary[resourceName].value\n  }), {});\n  const props = keys.reduce((props, resourceName) => ({\n    ...props,\n    [`${resourceName}Status`]: dictionary[resourceName].status,\n    [`${resourceName}Error`]: dictionary[resourceName].error,\n    [`${resourceName}IsLoading`]: dictionary[resourceName].isLoading\n  }), {});\n  const methods = keys.reduce((methods, resourceName) => {\n    return {\n      ...methods,\n      [`${resourceName}HasValue`]: () => dictionary[resourceName].hasValue(),\n      [`_${resourceName}Reload`]: () => dictionary[resourceName].reload()\n    };\n  }, {});\n  return signalStoreFeature(withLinkedState(() => state), withProps(() => props), withMethods(() => methods));\n}\nfunction isResourceRef(value) {\n  return value !== null && typeof value === 'object' && 'value' in value && isSignal(value.value) && 'status' in value && 'error' in value && 'isLoading' in value && 'hasValue' in value && 'reload' in value;\n}\n//** Implementation of `mapToResource` */\n/**\n * @experimental\n * @description\n *\n * Maps a named resource to type `Resource<T>`.\n *\n * @usageNotes\n *\n * ```ts\n * const store = signalStore(\n *   withState({ userId: undefined as number | undefined }),\n *   withResource(({ userId }) => ({\n *     user: httpResource<User[]>(() => '/users', { defaultValue: [] }),\n *   }))\n * );\n * const userResource = mapToResource(store, 'user');\n * userResource satisfies Resource<User[]>;\n * ```\n *\n * @param store The store instance to map the resource to.\n * @param name The name of the resource to map.\n * @returns `ResourceRef<T>`\n */\nfunction mapToResource(store, name) {\n  const resourceName = String(name);\n  function hasValue() {\n    return store[`${resourceName}HasValue`]();\n  }\n  return {\n    value: store[`${resourceName}Value`],\n    status: store[`${resourceName}Status`],\n    error: store[`${resourceName}Error`],\n    isLoading: store[`${resourceName}IsLoading`],\n    hasValue\n  };\n}\n\n/**\n * Creates an HTTP mutation.\n *\n * ```typescript\n * export type Params = {\n *   value: number;\n * };\n *\n * export type CounterResponse = {\n *   // httpbin.org echos the request using the\n *   // json property\n *   json: { counter: number };\n * };\n *\n * const simpleSaveUser = httpMutation({\n *   request: (userData: AddUserEntry) => ({\n *     url: 'api/users',\n *     body: userData,\n *   }),\n *   parse: Boolean,\n * })\n *\n * const saveUser = httpMutation({\n *   request: (p: Params) => ({\n *     url: `https://httpbin.org/post`,\n *     method: 'POST',\n *     body: { counter: p.value },\n *     headers: { 'Content-Type': 'application/json' },\n *   }),\n *   onSuccess: (response: CounterResponse) => {\n *     console.log('Counter sent to server:', response);\n *   },\n *   onError: (error) => {\n *     console.error('Failed to send counter:', error);\n *   },\n * });\n *\n * const result = await this.saveUser({ value: 17 });\n * if (result.status === 'success') {\n *   console.log('Successfully saved to server:', result.value);\n * }\n * else if (result.status === 'error') {\n *   console.log('Failed to save:', result.error);\n * }\n * else {\n *   console.log('Operation aborted');\n * }\n * ```\n *\n * @param options The options for the HTTP mutation.\n * @returns The HTTP mutation.\n */\nfunction httpMutation(optionsOrRequest) {\n  const httpClient = inject(HttpClient);\n  const options = typeof optionsOrRequest === 'function' ? {\n    request: optionsOrRequest\n  } : optionsOrRequest;\n  const parse = options.parse ?? (raw => raw);\n  const uploadProgress = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"uploadProgress\"\n  }] : []));\n  const downloadProgress = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"downloadProgress\"\n  }] : []));\n  const headers = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"headers\"\n  }] : []));\n  const statusCode = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"statusCode\"\n  }] : []));\n  const mutation = rxMutation({\n    ...options,\n    operation: param => {\n      const httpRequest = options.request(param);\n      return defer(() => {\n        uploadProgress.set(undefined);\n        downloadProgress.set(undefined);\n        headers.set(undefined);\n        statusCode.set(undefined);\n        return httpClient.request(httpRequest.method, httpRequest.url, {\n          ...httpRequest,\n          observe: 'events',\n          responseType: 'json'\n        }).pipe(tap(response => {\n          if (response.type === HttpEventType.UploadProgress) {\n            uploadProgress.set(response);\n          } else if (response.type === HttpEventType.DownloadProgress) {\n            downloadProgress.set(response);\n          }\n        }), filter(event => event instanceof HttpResponse), tap(response => {\n          headers.set(response.headers);\n          statusCode.set(response.status.toString());\n        }), map(event => parse(event.body)));\n      });\n    }\n  });\n  mutation.uploadProgress = uploadProgress;\n  mutation.downloadProgress = downloadProgress;\n  mutation.statusCode = statusCode;\n  mutation.headers = headers;\n  return mutation;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { capitalize, concatOp, createEffects, createPageArray, createReducer, deriveCallStateKeys, emptyFeature, exhaustOp, firstPage, getCallStateKeys, getCollectionArray, getDataServiceKeys, getUndoRedoKeys, gotoPage, httpMutation, mapToResource, mergeOp, nextPage, noPayload, patchState, payload, previousPage, provideDevtoolsConfig, renameDevtoolsName, rxMutation, setError, setLoaded, setLoading, setMaxPageNavigationArrayItems, setPageSize, setResetState, switchOp, updateState, withCallState, withConditional, withDataService, withDevToolsStub, withDevtools, withDisabledNameIndices, withFeatureFactory, withGlitchTracking, withImmutableState, withIndexedDB, withIndexedDB as withIndexeddb, withLocalStorage, withMapper, withMutations, withPagination, withRedux, withReset, withResource, withSessionStorage, withStorageSync, withUndoRedo };\n","import { withReset, withStorageSync } from '@angular-architects/ngrx-toolkit';\r\nimport { HttpErrorResponse } from '@angular/common/http';\r\nimport { inject } from '@angular/core';\r\nimport { Router } from '@angular/router';\r\nimport { LoginUserRequest } from '@model/dto/request/login-user.request';\r\nimport { tapResponse } from '@ngrx/operators';\r\nimport {\r\n  patchState,\r\n  signalStore,\r\n  withMethods,\r\n  withProps,\r\n  withState,\r\n} from '@ngrx/signals';\r\nimport { AuthService } from '../../modules/auth/services/auth.service';\r\nimport { TokenResponse } from '../models/common-models';\r\nimport { RegisterUserRequest } from '../models/dto/request/register-user.request';\r\nimport { AuthUserResponse } from '../models/dto/response/auth-user.response';\r\nimport { Member } from '../models/member.model';\r\nimport { User } from '../models/user.model';\r\nimport { MemberService } from '../services/member.service';\r\nimport { ToastService } from '../services/toast.service';\r\nimport { GlobalStore } from './global.store';\r\n\r\ntype AuthStoreType = {\r\n  currentUser: User | undefined;\r\n  memberDetails: Member | undefined;\r\n  isLoggedIn: boolean;\r\n  token: TokenResponse | undefined;\r\n};\r\n\r\nconst initialState: AuthStoreType = {\r\n  currentUser: undefined,\r\n  memberDetails: undefined,\r\n  isLoggedIn: false,\r\n  token: undefined,\r\n};\r\n\r\nexport const AuthStore = signalStore(\r\n  { providedIn: 'root' },\r\n  withState(initialState),\r\n  withStorageSync('auth'),\r\n  withReset(),\r\n  withProps(() => ({\r\n    globalStore: inject(GlobalStore),\r\n    authService: inject(AuthService),\r\n    memberService: inject(MemberService),\r\n    toastService: inject(ToastService),\r\n    router: inject(Router),\r\n  })),\r\n  withMethods((store) => {\r\n    const setCurrentUser = (user: User | undefined) => {\r\n      patchState(store, { currentUser: user });\r\n    };\r\n\r\n    const setMemberDetails = (memberDetails: Member | undefined) => {\r\n      patchState(store, { memberDetails });\r\n    };\r\n\r\n    const setIsLoggedIn = (isLoggedIn: boolean) => {\r\n      patchState(store, { isLoggedIn });\r\n    };\r\n\r\n    const setToken = (token: TokenResponse | undefined) => {\r\n      patchState(store, { token });\r\n    };\r\n\r\n    const signIn = store.globalStore.withFormSubmission<\r\n      LoginUserRequest,\r\n      AuthUserResponse\r\n    >((payload) =>\r\n      store.authService.login(payload).pipe(\r\n        tapResponse({\r\n          next: (response) => {\r\n            store.toastService.show(\r\n              `Welcome ${response.displayName}!`,\r\n              'success'\r\n            );\r\n            setIsLoggedIn(true);\r\n            setToken(response.token);\r\n            getCurrentUser();\r\n          },\r\n          error: (error: HttpErrorResponse) => {\r\n            console.error('Login error:', error);\r\n          },\r\n        })\r\n      )\r\n    );\r\n\r\n    const signUp = store.globalStore.withFormSubmission<\r\n      RegisterUserRequest,\r\n      AuthUserResponse\r\n    >((payload) =>\r\n      store.authService.registerUser(payload).pipe(\r\n        tapResponse({\r\n          next: (response) => {\r\n            store.toastService.show(\r\n              `Welcome ${response.displayName}!`,\r\n              'success'\r\n            );\r\n            setIsLoggedIn(true);\r\n            setToken(response.token);\r\n            getCurrentUser();\r\n          },\r\n          error: (error: HttpErrorResponse) => {\r\n            console.error('Registration error:', error);\r\n          },\r\n        })\r\n      )\r\n    );\r\n\r\n    const logout = () => {\r\n      store.resetState();\r\n      setIsLoggedIn(false);\r\n      setToken(undefined);\r\n      setCurrentUser(undefined);\r\n      store.toastService.show('Logged out successfully.', 'success');\r\n      store.router.navigate(['/home']);\r\n    };\r\n\r\n    const getCurrentUser = store.globalStore.withApiState<void, User>(() =>\r\n      store.authService.getCurrentUser().pipe(\r\n        tapResponse({\r\n          next: (response) => {\r\n            setCurrentUser(response);\r\n            setMemberDetails(response.memberDetails);\r\n          },\r\n          error: (error: HttpErrorResponse) => {\r\n            console.error('Get Current User error:', error);\r\n            // force logout\r\n            setTimeout(() => {\r\n              logout();\r\n            }, 1000);\r\n          },\r\n        })\r\n      )\r\n    );\r\n\r\n    return {\r\n      signIn,\r\n      signUp,\r\n      logout,\r\n      getCurrentUser,\r\n\r\n      setMemberDetails,\r\n    };\r\n  })\r\n);\r\n"],"mappings":"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","names":["DEVTOOLS_FEATURE","REDUX_DEVTOOLS_CONFIG","InjectionToken","EXISTING_NAMES","InjectionToken","withReset","signalStoreFeature","withProps","withMethods","store","patchState","state","withHooks","getState","SYNC_STATUS","LocalStorageService","_LocalStorageService","key","data","__ngFactoryType__","ÉµÉµdefineInjectable","SessionStorageService","_SessionStorageService","withLocalStorage","createSyncMethods","withSessionStorage","Storage","factory","parse","select","stringify","store","useStubs","storage","inject","stateString","patchState","slicedState","getState","withStorageSync","configOrKey","storageStrategy","config","__spreadValues","state","createSyncStorageSync","createAsyncStorageSync","signalStoreFeature","withMethods","platformId","PLATFORM_ID","isPlatformServer","withHooks","watchState","withProps","props","SYNC_STATUS","signal","resolves","effect","resolve","__spreadProps","computed","initialState","startWatching","emptyFeature","signalStoreFeature","withState","initialState","currentUser","undefined","memberDetails","isLoggedIn","token","AuthStore","signalStore","providedIn","withState","withStorageSync","withReset","withProps","globalStore","inject","GlobalStore","authService","AuthService","memberService","MemberService","toastService","ToastService","router","Router","withMethods","store","setCurrentUser","user","patchState","setMemberDetails","setIsLoggedIn","setToken","signIn","withFormSubmission","payload","login","pipe","tapResponse","next","response","show","displayName","getCurrentUser","error","console","signUp","registerUser","logout","resetState","navigate","withApiState","setTimeout"],"x_google_ignoreList":[0]}