{"version":3,"sources":["node_modules/@sweetalert2/ngx-sweetalert2/fesm2022/sweetalert2-ngx-sweetalert2.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, Injectable, EventEmitter, Output, Input, ChangeDetectionStrategy, Component, ViewContainerRef, ComponentFactoryResolver, HostListener, Directive, Injector, ApplicationRef, TemplateRef, NgModule, makeEnvironmentProviders } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nfunction SwalPortalComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nconst swalProviderToken = new InjectionToken(\"@sweetalert2/ngx-sweetalert2#swalProvider\");\nconst fireOnInitToken = new InjectionToken(\"@sweetalert2/ngx-sweetalert2#fireOnInit\");\nconst dismissOnDestroyToken = new InjectionToken(\"@sweetalert2/ngx-sweetalert2#dismissOnDestroy\");\nlet SweetAlert2LoaderService = /*#__PURE__*/(() => {\n  class SweetAlert2LoaderService {\n    swalProvider = inject(swalProviderToken);\n    swalPromiseCache;\n    get swal() {\n      if (!this.swalPromiseCache) {\n        this.preloadSweetAlertLibrary();\n      }\n      return this.swalPromiseCache;\n    }\n    preloadSweetAlertLibrary() {\n      if (this.swalPromiseCache) return;\n      const libPromise = isLoader(this.swalProvider) ? this.swalProvider() : Promise.resolve(this.swalProvider);\n      this.swalPromiseCache = libPromise.then(value => isDefaultExport(value) ? value : value.default);\n      function isLoader(value) {\n        return typeof value === \"function\" && value.version === undefined;\n      }\n      function isDefaultExport(value) {\n        return typeof value === \"function\";\n      }\n    }\n    static ɵfac = function SweetAlert2LoaderService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SweetAlert2LoaderService)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SweetAlert2LoaderService,\n      factory: SweetAlert2LoaderService.ɵfac\n    });\n  }\n  return SweetAlert2LoaderService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.\n *\n * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,\n *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.\n *\n * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.\n *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.\n *     If you are really concerned about performance and/or don't care about the API and its convenient integration\n *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)\n *\n * /!\\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`\n *     and `didDestroy`.\n *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,\n *     there can't be multiple listeners on them, and we need the values they can/must return.\n */\nlet SwalComponent = /*#__PURE__*/(() => {\n  class SwalComponent {\n    sweetAlert2Loader = inject(SweetAlert2LoaderService);\n    moduleLevelFireOnInit = inject(fireOnInitToken);\n    moduleLevelDismissOnDestroy = inject(dismissOnDestroyToken);\n    title;\n    titleText;\n    text;\n    html;\n    footer;\n    icon;\n    iconColor;\n    iconHtml;\n    backdrop;\n    toast;\n    target;\n    input;\n    width;\n    padding;\n    background;\n    position;\n    grow;\n    showClass;\n    hideClass;\n    customClass;\n    timer;\n    timerProgressBar;\n    heightAuto;\n    allowOutsideClick;\n    allowEscapeKey;\n    allowEnterKey;\n    stopKeydownPropagation;\n    keydownListenerCapture;\n    showConfirmButton;\n    showDenyButton;\n    showCancelButton;\n    confirmButtonText;\n    denyButtonText;\n    cancelButtonText;\n    confirmButtonColor;\n    denyButtonColor;\n    cancelButtonColor;\n    confirmButtonAriaLabel;\n    denyButtonAriaLabel;\n    cancelButtonAriaLabel;\n    buttonsStyling;\n    reverseButtons;\n    focusConfirm;\n    focusDeny;\n    focusCancel;\n    showCloseButton;\n    closeButtonHtml;\n    closeButtonAriaLabel;\n    loaderHtml;\n    showLoaderOnConfirm;\n    preConfirm;\n    preDeny;\n    imageUrl;\n    imageWidth;\n    imageHeight;\n    imageAlt;\n    inputLabel;\n    inputPlaceholder;\n    inputValue;\n    inputOptions;\n    inputAutoTrim;\n    inputAttributes;\n    inputValidator;\n    returnInputValueOnDeny;\n    validationMessage;\n    progressSteps;\n    currentProgressStep;\n    progressStepsDistance;\n    scrollbarPadding;\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n     *     previous properties you want to erase again.\n     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n     *\n     * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n     */\n    set swalOptions(options) {\n      //=> Update properties\n      Object.assign(this, options);\n      //=> Mark changed properties as touched\n      const touchedKeys = Object.keys(options);\n      touchedKeys.forEach(this.markTouched);\n    }\n    /**\n     * Computes the options object that will get passed to SweetAlert2.\n     * Only the properties that have been set at least once on this component will be returned.\n     * Mostly for internal usage.\n     */\n    get swalOptions() {\n      //=> We will compute the options object based on the option keys that are known to have changed.\n      //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially\n      //   avoiding side effects.\n      return [...this.touchedProps].reduce((obj, key) => ({\n        ...obj,\n        [key]: this[key]\n      }), {});\n    }\n    /**\n     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.\n     *\n     * Example:\n     *     <swal *ngIf=\"error\" [title]=\"error.title\" [text]=\"error.text\" icon=\"error\" [swalFireOnInit]=\"true\"></swal>\n     */\n    swalFireOnInit;\n    /**\n     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.\n     */\n    swalDismissOnDestroy;\n    set swalVisible(visible) {\n      if (visible) {\n        this.fire();\n      } else {\n        this.close();\n      }\n    }\n    get swalVisible() {\n      return this.isCurrentlyShown;\n    }\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n    willOpen = new EventEmitter();\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n    didOpen = new EventEmitter();\n    /**\n     * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is\n     * repainted on the screen).\n     * Typically, this will happen after `Swal.fire()` or `Swal.update()`.\n     * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over\n     * {@link willOpen}.\n     */\n    didRender = new EventEmitter();\n    /**\n     * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup\n     * being fired).\n     */\n    willClose = new EventEmitter();\n    /**\n     * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to\n     * another popup being fired).\n     */\n    didClose = new EventEmitter();\n    /**\n     * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another\n     * popup.\n     * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer\n     * {@link didDestroy} over {@link didClose}.\n     */\n    didDestroy = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * The event value ($event) can be either:\n     *  - by default, just `true`,\n     *  - when using {@link input}, the input value,\n     *  - when using {@link preConfirm}, the return value of this function.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    confirm = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Deny\".\n     * This event bears no value.\n     * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n     * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n     *\n     * Example:\n     *     <swal (deny)=\"handleDeny()\"></swal>\n     *\n     *     public handleDeny(): void {\n     *     }\n     */\n    deny = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n     * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n     * the modal was programmatically closed (through {@link close} for example).\n     *\n     * Example:\n     *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n     *\n     *     public handleDismiss(reason: DismissReason | undefined): void {\n     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n     *         // ... do something\n     *     }\n     */\n    dismiss = new EventEmitter();\n    /**\n     * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n     * what options we have to send to {@link Swal.fire}.\n     */\n    touchedProps = new Set();\n    /**\n     * A function of signature `(propName: string): void` that adds a given property name to the list of\n     * touched properties, ie. {@link touchedProps}.\n     */\n    markTouched = this.touchedProps.add.bind(this.touchedProps);\n    /**\n     * Is the SweetAlert2 modal represented by this component currently opened?\n     */\n    isCurrentlyShown = false;\n    /**\n     * Angular lifecycle hook.\n     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n     * causing no delay.\n     */\n    ngOnInit() {\n      //=> Preload SweetAlert2 library in case this component is activated.\n      this.sweetAlert2Loader.preloadSweetAlertLibrary();\n    }\n    /**\n     * Angular lifecycle hook.\n     * Fires the modal, if the component or module is configured to do so.\n     */\n    ngAfterViewInit() {\n      const fireOnInit = this.swalFireOnInit === undefined ? this.moduleLevelFireOnInit : this.swalFireOnInit;\n      if (fireOnInit) {\n        this.fire();\n      }\n    }\n    /**\n     * Angular lifecycle hook.\n     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n     */\n    ngOnChanges(changes) {\n      //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can\n      //   send it with the next fire() or update() calls.\n      Object.keys(changes)\n      //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter\n      .filter(key => !key.startsWith(\"swal\")).forEach(this.markTouched);\n      //=> Eventually trigger re-render if the modal is open.\n      void this.update();\n    }\n    /**\n     * Angular lifecycle hook.\n     * Closes the SweetAlert when the component is destroyed.\n     */\n    ngOnDestroy() {\n      //=> Release the modal if the component is destroyed and if that behaviour is not disabled.\n      const dismissOnDestroy = this.swalDismissOnDestroy === undefined ? this.moduleLevelDismissOnDestroy : this.swalDismissOnDestroy;\n      if (dismissOnDestroy) {\n        this.close();\n      }\n    }\n    /**\n     * Shows the SweetAlert.\n     *\n     * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n     * Otherwise, (confirm)=\"myHandler($event)\" and (dismiss)=\"myHandler($event)\" can be used in templates.\n     */\n    async fire() {\n      const swal = await this.sweetAlert2Loader.swal;\n      const userOptions = this.swalOptions;\n      //=> Build the SweetAlert2 options\n      const options = {\n        //=> Merge with calculated options set for that specific swal\n        ...userOptions,\n        //=> Handle modal lifecycle events\n        willOpen: composeHook(userOptions.willOpen, modalElement => {\n          this.willOpen.emit({\n            modalElement\n          });\n        }),\n        didOpen: composeHook(userOptions.didOpen, modalElement => {\n          this.isCurrentlyShown = true;\n          this.didOpen.emit({\n            modalElement\n          });\n        }),\n        didRender: composeHook(userOptions.didRender, modalElement => {\n          this.didRender.emit({\n            modalElement\n          });\n        }),\n        willClose: composeHook(userOptions.willClose, modalElement => {\n          this.isCurrentlyShown = false;\n          this.willClose.emit({\n            modalElement\n          });\n        }),\n        didClose: composeHook(userOptions.didClose, () => {\n          this.didClose.emit();\n        }),\n        didDestroy: composeHook(userOptions.didDestroy, () => {\n          this.didDestroy.emit();\n        })\n      };\n      //=> Show the Swal! And wait for confirmation or dimissal.\n      const result = await swal.fire(options);\n      //=> Emit on (confirm), (deny) or (dismiss)\n      switch (true) {\n        case result.isConfirmed:\n          this.confirm.emit(result.value);\n          break;\n        case result.isDenied:\n          this.deny.emit();\n          break;\n        case result.isDismissed:\n          this.dismiss.emit(result.dismiss);\n          break;\n      }\n      return result;\n      function composeHook(userHook, libHook) {\n        return (...args) => (libHook(...args), userHook?.(...args));\n      }\n    }\n    /**\n     * Closes the modal, if opened.\n     *\n     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).\n     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.\n     *               {@see Swal.close}.\n     */\n    async close(result) {\n      if (!this.isCurrentlyShown) return;\n      const swal = await this.sweetAlert2Loader.swal;\n      swal.close(result);\n    }\n    /**\n     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n     * If the modal is not opened, the component options will simply be updated and that's it.\n     *\n     * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n     *\n     * @param options\n     */\n    async update(options) {\n      if (options) {\n        this.swalOptions = options;\n      }\n      if (!this.isCurrentlyShown) return;\n      const swal = await this.sweetAlert2Loader.swal;\n      const allOptions = this.swalOptions;\n      const updatableOptions = Object.keys(allOptions).filter(swal.isUpdatableParameter).reduce((obj, key) => ({\n        ...obj,\n        [key]: allOptions[key]\n      }), {});\n      swal.update(updatableOptions);\n    }\n    static ɵfac = function SwalComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SwalComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: SwalComponent,\n      selectors: [[\"swal\"]],\n      inputs: {\n        title: \"title\",\n        titleText: \"titleText\",\n        text: \"text\",\n        html: \"html\",\n        footer: \"footer\",\n        icon: \"icon\",\n        iconColor: \"iconColor\",\n        iconHtml: \"iconHtml\",\n        backdrop: \"backdrop\",\n        toast: \"toast\",\n        target: \"target\",\n        input: \"input\",\n        width: \"width\",\n        padding: \"padding\",\n        background: \"background\",\n        position: \"position\",\n        grow: \"grow\",\n        showClass: \"showClass\",\n        hideClass: \"hideClass\",\n        customClass: \"customClass\",\n        timer: \"timer\",\n        timerProgressBar: \"timerProgressBar\",\n        heightAuto: \"heightAuto\",\n        allowOutsideClick: \"allowOutsideClick\",\n        allowEscapeKey: \"allowEscapeKey\",\n        allowEnterKey: \"allowEnterKey\",\n        stopKeydownPropagation: \"stopKeydownPropagation\",\n        keydownListenerCapture: \"keydownListenerCapture\",\n        showConfirmButton: \"showConfirmButton\",\n        showDenyButton: \"showDenyButton\",\n        showCancelButton: \"showCancelButton\",\n        confirmButtonText: \"confirmButtonText\",\n        denyButtonText: \"denyButtonText\",\n        cancelButtonText: \"cancelButtonText\",\n        confirmButtonColor: \"confirmButtonColor\",\n        denyButtonColor: \"denyButtonColor\",\n        cancelButtonColor: \"cancelButtonColor\",\n        confirmButtonAriaLabel: \"confirmButtonAriaLabel\",\n        denyButtonAriaLabel: \"denyButtonAriaLabel\",\n        cancelButtonAriaLabel: \"cancelButtonAriaLabel\",\n        buttonsStyling: \"buttonsStyling\",\n        reverseButtons: \"reverseButtons\",\n        focusConfirm: \"focusConfirm\",\n        focusDeny: \"focusDeny\",\n        focusCancel: \"focusCancel\",\n        showCloseButton: \"showCloseButton\",\n        closeButtonHtml: \"closeButtonHtml\",\n        closeButtonAriaLabel: \"closeButtonAriaLabel\",\n        loaderHtml: \"loaderHtml\",\n        showLoaderOnConfirm: \"showLoaderOnConfirm\",\n        preConfirm: \"preConfirm\",\n        preDeny: \"preDeny\",\n        imageUrl: \"imageUrl\",\n        imageWidth: \"imageWidth\",\n        imageHeight: \"imageHeight\",\n        imageAlt: \"imageAlt\",\n        inputLabel: \"inputLabel\",\n        inputPlaceholder: \"inputPlaceholder\",\n        inputValue: \"inputValue\",\n        inputOptions: \"inputOptions\",\n        inputAutoTrim: \"inputAutoTrim\",\n        inputAttributes: \"inputAttributes\",\n        inputValidator: \"inputValidator\",\n        returnInputValueOnDeny: \"returnInputValueOnDeny\",\n        validationMessage: \"validationMessage\",\n        progressSteps: \"progressSteps\",\n        currentProgressStep: \"currentProgressStep\",\n        progressStepsDistance: \"progressStepsDistance\",\n        scrollbarPadding: \"scrollbarPadding\",\n        swalOptions: \"swalOptions\",\n        swalFireOnInit: \"swalFireOnInit\",\n        swalDismissOnDestroy: \"swalDismissOnDestroy\",\n        swalVisible: \"swalVisible\"\n      },\n      outputs: {\n        willOpen: \"willOpen\",\n        didOpen: \"didOpen\",\n        didRender: \"didRender\",\n        willClose: \"willClose\",\n        didClose: \"didClose\",\n        didDestroy: \"didDestroy\",\n        confirm: \"confirm\",\n        deny: \"deny\",\n        dismiss: \"dismiss\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 0,\n      vars: 0,\n      template: function SwalComponent_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return SwalComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:\n *\n * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:\n *\n *    <button [swal]=\"['Title', 'Text']\">Click me</button>\n *\n * 2) A native SweetAlert2 options object, ex:\n *\n *    <button [swal]=\"{ title: 'Title', text: 'Text' }\">Click me</button>\n *\n * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:\n *\n *    <button [swal]=\"mySwal\">Click me</button>\n *    <swal #mySwal title=\"Title\" text=\"Text\"></swal>\n */\nlet SwalDirective = /*#__PURE__*/(() => {\n  class SwalDirective {\n    viewContainerRef = inject(ViewContainerRef);\n    resolver = inject(ComponentFactoryResolver);\n    /**\n     * SweetAlert2 options or a SwalComponent instance.\n     * See the class doc block for more informations.\n     */\n    set swal(options) {\n      if (options instanceof SwalComponent) {\n        this.swalInstance = options;\n      } else if (isArrayOptions(options)) {\n        this.swalOptions = {};\n        [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;\n      } else {\n        this.swalOptions = options;\n      }\n      function isArrayOptions(value) {\n        return Array.isArray(options);\n      }\n    }\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * The event value ($event) can be either:\n     *  - by default, just `true`,\n     *  - when using {@link input}, the input value,\n     *  - when using {@link preConfirm}, the return value of this function.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    confirm = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Deny\".\n     * This event bears no value.\n     * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n     * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n     *\n     * Example:\n     *     <swal (deny)=\"handleDeny()\"></swal>\n     *\n     *     public handleDeny(): void {\n     *     }\n     */\n    deny = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n     * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n     * the modal was programmatically closed (through {@link dismiss} for example).\n     *\n     * Example:\n     *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n     *\n     *     public handleDismiss(reason: DismissReason | undefined): void {\n     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n     *         // ... do something\n     *     }\n     */\n    dismiss = new EventEmitter();\n    /**\n     * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object\n     * options to it.\n     * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.\n     */\n    swalRef;\n    /**\n     * An instance of the <swal> component that this directive controls.\n     * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.\n     */\n    swalInstance;\n    /**\n     * Holds the native SweetAlert2 options.\n     * Empty when the user passed an existing SwalComponent instance.\n     */\n    swalOptions;\n    /**\n     * OnInit lifecycle handler.\n     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),\n     * (deny) and (dismiss) outputs to reemit on the directive.\n     */\n    ngOnInit() {\n      if (!this.swalInstance) {\n        const factory = this.resolver.resolveComponentFactory(SwalComponent);\n        this.swalRef = this.viewContainerRef.createComponent(factory);\n        this.swalInstance = this.swalRef.instance;\n      }\n    }\n    /**\n     * OnDestroy lifecycle handler.\n     * Destroys the dynamically-created SwalComponent.\n     */\n    ngOnDestroy() {\n      if (this.swalRef) {\n        this.swalRef.destroy();\n      }\n    }\n    /**\n     * Click handler.\n     * The directive listens for onclick events on its host element.\n     * When this happens, it shows the <swal> attached to this directive.\n     */\n    onClick(event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      if (!this.swalInstance) return;\n      if (this.swalOptions) {\n        this.swalInstance.swalOptions = this.swalOptions;\n      }\n      const swalClosed = new Subject();\n      this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.confirm.emit(v));\n      this.swalInstance.deny.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.deny.emit(v));\n      this.swalInstance.dismiss.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.dismiss.emit(v));\n      this.swalInstance.fire().then(() => swalClosed.next());\n    }\n    static ɵfac = function SwalDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SwalDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: SwalDirective,\n      selectors: [[\"\", \"swal\", \"\"]],\n      hostBindings: function SwalDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function SwalDirective_click_HostBindingHandler($event) {\n            return ctx.onClick($event);\n          });\n        }\n      },\n      inputs: {\n        swal: \"swal\"\n      },\n      outputs: {\n        confirm: \"confirm\",\n        deny: \"deny\",\n        dismiss: \"dismiss\"\n      }\n    });\n  }\n  return SwalDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents an object of targets for <swal> portals (use with *swalPortal directive).\n * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\nlet SwalPortalTargets = /*#__PURE__*/(() => {\n  class SwalPortalTargets {\n    /**\n     * Targets the modal close button block contents.\n     */\n    closeButton = {\n      element: swal => swal.getCloseButton(),\n      options: {\n        showCloseButton: true\n      }\n    };\n    /**\n     * Targets the modal title block contents.\n     */\n    title = {\n      element: swal => swal.getTitle(),\n      // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n      options: {\n        title: \" \"\n      }\n    };\n    /**\n     * Targets the modal text block contents (that is another block inside the first content block, so you can still\n     * use other modal features like Swal inputs, that are situated inside that parent content block).\n     */\n    content = {\n      element: swal => swal.getHtmlContainer(),\n      // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n      options: {\n        text: \" \"\n      }\n    };\n    /**\n     * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.\n     * /!\\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this\n     *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.\n     *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and\n     *     performance of everyone, for a relatively rare use case.\n     */\n    actions = {\n      element: swal => swal.getActions(),\n      // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.\n      options: {\n        showConfirmButton: true\n      }\n    };\n    /**\n     * Targets the confirm button contents, replacing the text inside it (not the button itself)\n     */\n    confirmButton = {\n      element: swal => swal.getConfirmButton(),\n      options: {\n        showConfirmButton: true\n      }\n    };\n    /**\n     * Targets the deny button contents, replacing the text inside it (not the button itself)\n     */\n    denyButton = {\n      element: swal => swal.getDenyButton(),\n      options: {\n        showDenyButton: true\n      }\n    };\n    /**\n     * Targets the cancel button contents, replacing the text inside it (not the button itself)\n     */\n    cancelButton = {\n      element: swal => swal.getCancelButton(),\n      options: {\n        showCancelButton: true\n      }\n    };\n    /**\n     * Targets the modal footer contents.\n     */\n    footer = {\n      element: swal => swal.getFooter(),\n      // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n      options: {\n        footer: \" \"\n      }\n    };\n    static ɵfac = function SwalPortalTargets_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SwalPortalTargets)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SwalPortalTargets,\n      factory: SwalPortalTargets.ɵfac,\n      providedIn: \"root\"\n    });\n  }\n  return SwalPortalTargets;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @internal\n * Holds a consumer's Angular template and displays it on a Sweet Alert.\n * See SwalPortalDirective for info about the covered feature.\n */\nlet SwalPortalComponent = /*#__PURE__*/(() => {\n  class SwalPortalComponent {\n    template = null;\n    static ɵfac = function SwalPortalComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SwalPortalComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: SwalPortalComponent,\n      selectors: [[\"swal-portal\"]],\n      inputs: {\n        template: \"template\"\n      },\n      decls: 1,\n      vars: 1,\n      consts: [[4, \"ngTemplateOutlet\"]],\n      template: function SwalPortalComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, SwalPortalComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n        }\n      },\n      dependencies: [CommonModule, i1.NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return SwalPortalComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A structural directive that lets you use Angular templates inside of SweetAlerts.\n * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but\n * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.\n * The default target is the alert text content zone.\n *\n * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):\n *\n *     @Component({ ... })\n *     export class MyComponent {\n *         public constructor(public readonly swalTargets: SwalPortalTargets) {\n *         }\n *     }\n *\n * Usage in the template:\n *\n *     <swal title=\"Fill the form\" (confirm)=\"confirmHandler()\">\n *         <!-- This form will be displayed as the alert main content\n *              Targets the alert's main content zone by default -->\n *         <form *swalPortal [formControl]=\"myForm\">\n *             ...\n *         </form>\n *\n *         <!-- This targets the confirm button's inner content\n *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->\n *         <ng-container *swalPortal=\"swalTargets.confirmButton\">\n *              Send ({{ secondsLeft }} seconds left)\n *         </ng-container>\n *     <swal>\n */\nlet SwalPortalDirective = /*#__PURE__*/(() => {\n  class SwalPortalDirective {\n    resolver = inject(ComponentFactoryResolver);\n    injector = inject(Injector);\n    app = inject(ApplicationRef);\n    templateRef = inject(TemplateRef);\n    sweetAlert2Loader = inject(SweetAlert2LoaderService);\n    swalTargets = inject(SwalPortalTargets);\n    swalComponent = inject(SwalComponent, {\n      host: true\n    });\n    /**\n     * Takes a portal target or nothing (then it will target the text content zone by default).\n     *\n     * See the {@link SwalPortalTargets} service to see the available targets.\n     * See the class doc block for more informations.\n     */\n    target;\n    /**\n     * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.\n     */\n    portalComponentRef;\n    destroyed = new Subject();\n    /**\n     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent\n     * that will receive the consumer's template.\n     */\n    ngOnInit() {\n      // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.\n      this.target = this.target || this.swalTargets.content;\n      //=> Apply the options provided by the target definition\n      void this.swalComponent.update(this.target.options);\n      //=> Subscribe to a few hooks frm the parent SwalComponent.\n      this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));\n      this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));\n      this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));\n    }\n    /**\n     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the\n     * parent SwalComponent events.\n     */\n    ngOnDestroy() {\n      this.destroyed.next();\n    }\n    /**\n     * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the\n     * {@link willOpenHook}), or after Swal.update() is called.\n     * This is a good place to render, or re-render, our portal contents.\n     */\n    async didRenderHook() {\n      //=> Ensure the portal component is created\n      if (!this.portalComponentRef) {\n        this.portalComponentRef = this.createPortalComponent();\n      }\n      //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.\n      // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside\n      // this function is already resolved at this point), so the whole process of re-rendering and re-mounting\n      // the portal component is fully synchronous, causing no blinks in the modal contents.\n      const swal = await this.sweetAlert2Loader.swal;\n      //=> Find target element\n      const targetEl = this.target.element(swal);\n      if (!targetEl) return;\n      //=> Replace target's contents with our component\n      // https://jsperf.com/innerhtml-vs-removechild/15\n      while (targetEl.firstChild) {\n        targetEl.removeChild(targetEl.firstChild);\n      }\n      targetEl.appendChild(this.portalComponentRef.location.nativeElement);\n    }\n    /**\n     * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.\n     * This is a good place to declare our detached view to the Angular app.\n     */\n    willOpenHook() {\n      if (!this.portalComponentRef) return;\n      //=> Make the Angular app aware of that detached view so rendering and change detection can happen\n      this.app.attachView(this.portalComponentRef.hostView);\n    }\n    /**\n     * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.\n     * This is a good place to detach and destroy our content, that is not visible anymore.\n     */\n    didDestroyHook() {\n      if (!this.portalComponentRef) return;\n      //=> Detach the portal component from the app and destroy it\n      this.app.detachView(this.portalComponentRef.hostView);\n      this.portalComponentRef.destroy();\n      this.portalComponentRef = void 0;\n    }\n    /**\n     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.\n     */\n    createPortalComponent() {\n      //=> Create the SwalPortalComponent that will hold our content\n      const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);\n      // Yes, we do not use the third argument that would directly use the target as the component's view\n      // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)\n      // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be\n      // able to restore it at any moment, ie. after the modal has been re-rendered.\n      const componentRef = factory.create(this.injector, []);\n      //=> Apply the consumer's template on the component\n      componentRef.instance.template = this.templateRef;\n      return componentRef;\n    }\n    static ɵfac = function SwalPortalDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SwalPortalDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: SwalPortalDirective,\n      selectors: [[\"\", \"swalPortal\", \"\"]],\n      inputs: {\n        target: [0, \"swalPortal\", \"target\"]\n      }\n    });\n  }\n  return SwalPortalDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideDefaultSwal$1() {\n  return import('sweetalert2');\n}\n/**\n * @deprecated Use provideSweetAlert2() instead for new applications with standalone components.\n * This module is kept for backward compatibility with existing applications using NgModules.\n */\nlet SweetAlert2Module = /*#__PURE__*/(() => {\n  class SweetAlert2Module {\n    static forRoot(options = {}) {\n      return {\n        ngModule: SweetAlert2Module,\n        providers: [SweetAlert2LoaderService, SwalPortalTargets, {\n          provide: swalProviderToken,\n          useValue: options.provideSwal || provideDefaultSwal$1\n        }, {\n          provide: fireOnInitToken,\n          useValue: options.fireOnInit || false\n        }, {\n          provide: dismissOnDestroyToken,\n          useValue: options.dismissOnDestroy || true\n        }]\n      };\n    }\n    static forChild(options = {}) {\n      return {\n        ngModule: SweetAlert2Module,\n        providers: [...(options.provideSwal ? [SweetAlert2LoaderService, {\n          provide: swalProviderToken,\n          useValue: options.provideSwal\n        }] : []), ...(options.fireOnInit !== undefined ? [{\n          provide: fireOnInitToken,\n          useValue: options.fireOnInit\n        }] : []), ...(options.dismissOnDestroy !== undefined ? [{\n          provide: dismissOnDestroyToken,\n          useValue: options.dismissOnDestroy\n        }] : [])]\n      };\n    }\n    static ɵfac = function SweetAlert2Module_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SweetAlert2Module)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: SweetAlert2Module\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, SwalPortalComponent]\n    });\n  }\n  return SweetAlert2Module;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideDefaultSwal() {\n  return import('sweetalert2');\n}\n/**\n * Provides SweetAlert2 services for Angular applications using the modern provider pattern.\n * Use this instead of SweetAlert2Module.forRoot() for standalone applications.\n *\n * @param config Configuration options for SweetAlert2\n * @returns EnvironmentProviders that can be used in ApplicationConfig or bootstrapApplication\n *\n * @example\n * ```typescript\n * // In your main.ts or app.config.ts\n * import { provideSweetAlert2 } from '@sweetalert2/ngx-sweetalert2';\n *\n * export const appConfig: ApplicationConfig = {\n *   providers: [\n *     // other providers\n *     provideSweetAlert2(),\n *     // or with configuration\n *     provideSweetAlert2({\n *       fireOnInit: false,\n *       dismissOnDestroy: true\n *     })\n *   ]\n * };\n * ```\n */\nfunction provideSweetAlert2(config = {}) {\n  return makeEnvironmentProviders([SweetAlert2LoaderService, SwalPortalTargets, {\n    provide: swalProviderToken,\n    useValue: config.provideSwal ?? provideDefaultSwal\n  }, {\n    provide: fireOnInitToken,\n    useValue: config.fireOnInit ?? false\n  }, {\n    provide: dismissOnDestroyToken,\n    useValue: config.dismissOnDestroy ?? true\n  }]);\n}\n/**\n * Provides SweetAlert2 services for feature modules.\n * Use this in lazy-loaded modules that need different SweetAlert2 configuration.\n *\n * @param config Configuration options for SweetAlert2\n * @returns Array of providers that can be used in a feature module\n *\n * @example\n * ```typescript\n * // In a feature module or component providers\n * import { provideSweetAlert2ForFeature } from '@sweetalert2/ngx-sweetalert2';\n *\n * @Component({\n *   providers: [\n *     ...provideSweetAlert2ForFeature({\n *       dismissOnDestroy: false\n *     })\n *   ]\n * })\n * export class MyFeatureComponent {}\n * ```\n */\nfunction provideSweetAlert2ForFeature(config = {}) {\n  const providers = [];\n  if (config.provideSwal) {\n    providers.push(SweetAlert2LoaderService, {\n      provide: swalProviderToken,\n      useValue: config.provideSwal\n    });\n  }\n  if (config.fireOnInit !== undefined) {\n    providers.push({\n      provide: fireOnInitToken,\n      useValue: config.fireOnInit\n    });\n  }\n  if (config.dismissOnDestroy !== undefined) {\n    providers.push({\n      provide: dismissOnDestroyToken,\n      useValue: config.dismissOnDestroy\n    });\n  }\n  return providers;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SwalComponent, SwalDirective, SwalPortalComponent, SwalPortalDirective, SwalPortalTargets, SweetAlert2LoaderService, SweetAlert2Module, provideSweetAlert2, provideSweetAlert2ForFeature };\n"],"mappings":"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","names":["swalProviderToken","InjectionToken","fireOnInitToken","dismissOnDestroyToken","SweetAlert2LoaderService","inject","libPromise","isLoader","value","isDefaultExport","__ngFactoryType__","ɵɵdefineInjectable","SwalComponent","options","obj","key","__spreadProps","__spreadValues","visible","EventEmitter","changes","swal","userOptions","composeHook","modalElement","result","userHook","libHook","args","allOptions","updatableOptions","ɵɵdefineComponent","ɵɵNgOnChangesFeature","rf","ctx","SwalPortalTargets","swal","__ngFactoryType__","ɵɵdefineInjectable","provideDefaultSwal","provideSweetAlert2","config","makeEnvironmentProviders","SweetAlert2LoaderService","SwalPortalTargets","swalProviderToken","fireOnInitToken","dismissOnDestroyToken"],"x_google_ignoreList":[0]}