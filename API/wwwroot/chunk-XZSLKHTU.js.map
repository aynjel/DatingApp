{"version":3,"sources":["src/app/shared/services/toast.service.ts","node_modules/@ngrx/signals/fesm2022/ngrx-signals.mjs","node_modules/@ngrx/operators/fesm2022/ngrx-operators.mjs","node_modules/@ngrx/signals/fesm2022/ngrx-signals-rxjs-interop.mjs","src/app/shared/store/global.store.ts"],"sourcesContent":["import { Injectable, signal } from '@angular/core';\r\nimport { Toast } from '../models/user.model';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class ToastService {\r\n  toasts = signal<Toast[]>([]);\r\n  private counter = 0;\r\n\r\n  show(message: string, type: Toast['type'] = 'info', duration = 3000) {\r\n    const id = this.counter++;\r\n    const newToast: Toast = {\r\n      id,\r\n      message,\r\n      type,\r\n      duration,\r\n    };\r\n    this.toasts.set([...this.toasts(), newToast]);\r\n\r\n    if (duration > 0) {\r\n      setTimeout(() => this.remove(id), duration);\r\n    }\r\n  }\r\n\r\n  remove(id: number) {\r\n    this.toasts.set(this.toasts().filter((t) => t.id !== id));\r\n  }\r\n}\r\n","import * as i0 from '@angular/core';\nimport { untracked, isSignal, computed, assertInInjectionContext, inject, Injector, effect, DestroyRef, signal, Injectable, linkedSignal } from '@angular/core';\nconst DEEP_SIGNAL = Symbol('DEEP_SIGNAL');\nfunction toDeepSignal(signal) {\n  return new Proxy(signal, {\n    has(target, prop) {\n      return !!this.get(target, prop, undefined);\n    },\n    get(target, prop) {\n      const value = untracked(target);\n      if (!isRecord(value) || !(prop in value)) {\n        if (isSignal(target[prop]) && target[prop][DEEP_SIGNAL]) {\n          delete target[prop];\n        }\n        return target[prop];\n      }\n      if (!isSignal(target[prop])) {\n        Object.defineProperty(target, prop, {\n          value: computed(() => target()[prop]),\n          configurable: true\n        });\n        target[prop][DEEP_SIGNAL] = true;\n      }\n      return toDeepSignal(target[prop]);\n    }\n  });\n}\nconst nonRecords = [WeakSet, WeakMap, Promise, Date, Error, RegExp, ArrayBuffer, DataView, Function];\nfunction isRecord(value) {\n  if (value === null || typeof value !== 'object' || isIterable(value)) {\n    return false;\n  }\n  let proto = Object.getPrototypeOf(value);\n  if (proto === Object.prototype) {\n    return true;\n  }\n  while (proto && proto !== Object.prototype) {\n    if (nonRecords.includes(proto.constructor)) {\n      return false;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return proto === Object.prototype;\n}\nfunction isIterable(value) {\n  return typeof value?.[Symbol.iterator] === 'function';\n}\nfunction deepComputed(computation) {\n  return toDeepSignal(computed(computation));\n}\nfunction signalMethod(processingFn, config) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && !config?.injector) {\n    assertInInjectionContext(signalMethod);\n  }\n  const watchers = [];\n  const sourceInjector = config?.injector ?? inject(Injector);\n  const signalMethodFn = (input, config) => {\n    if (isSignal(input)) {\n      const callerInjector = getCallerInjector();\n      if (typeof ngDevMode !== 'undefined' && ngDevMode && config?.injector === undefined && callerInjector === undefined) {\n        console.warn('@ngrx/signals: The function returned by signalMethod was called', 'outside the injection context with a signal. This may lead to', 'a memory leak. Make sure to call it within the injection context', '(e.g. in a constructor or field initializer) or pass an injector', 'explicitly via the config parameter.\\n\\nFor more information, see:', 'https://ngrx.io/guide/signals/signal-method#automatic-cleanup');\n      }\n      const instanceInjector = config?.injector ?? callerInjector ?? sourceInjector;\n      const watcher = effect(() => {\n        const value = input();\n        untracked(() => processingFn(value));\n      }, {\n        injector: instanceInjector\n      });\n      watchers.push(watcher);\n      instanceInjector.get(DestroyRef).onDestroy(() => {\n        const ix = watchers.indexOf(watcher);\n        if (ix !== -1) {\n          watchers.splice(ix, 1);\n        }\n      });\n      return watcher;\n    } else {\n      processingFn(input);\n      return {\n        destroy: () => void true\n      };\n    }\n  };\n  signalMethodFn.destroy = () => watchers.forEach(watcher => watcher.destroy());\n  return signalMethodFn;\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch {\n    return undefined;\n  }\n}\nconst STATE_WATCHERS = new WeakMap();\nconst STATE_SOURCE = Symbol('STATE_SOURCE');\nfunction isWritableSignal(value) {\n  return isSignal(value) && 'set' in value && 'update' in value && typeof value.set === 'function' && typeof value.update === 'function';\n}\nfunction isWritableStateSource(stateSource) {\n  const signals = stateSource[STATE_SOURCE];\n  return Reflect.ownKeys(stateSource[STATE_SOURCE]).every(key => {\n    return isWritableSignal(signals[key]);\n  });\n}\nfunction patchState(stateSource, ...updaters) {\n  const currentState = untracked(() => getState(stateSource));\n  const newState = updaters.reduce((nextState, updater) => ({\n    ...nextState,\n    ...(typeof updater === 'function' ? updater(nextState) : updater)\n  }), currentState);\n  const signals = stateSource[STATE_SOURCE];\n  const stateKeys = Reflect.ownKeys(stateSource[STATE_SOURCE]);\n  for (const key of Reflect.ownKeys(newState)) {\n    if (stateKeys.includes(key)) {\n      const signalKey = key;\n      if (currentState[signalKey] !== newState[signalKey]) {\n        signals[signalKey].set(newState[signalKey]);\n      }\n    } else if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      console.warn(`@ngrx/signals: patchState was called with an unknown state slice '${String(key)}'.`, 'Ensure that all state properties are explicitly defined in the initial state.', 'Updates to properties not present in the initial state will be ignored.');\n    }\n  }\n  notifyWatchers(stateSource);\n}\nfunction getState(stateSource) {\n  const signals = stateSource[STATE_SOURCE];\n  return Reflect.ownKeys(stateSource[STATE_SOURCE]).reduce((state, key) => {\n    const value = signals[key]();\n    return {\n      ...state,\n      [key]: value\n    };\n  }, {});\n}\nfunction watchState(stateSource, watcher, config) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && !config?.injector) {\n    assertInInjectionContext(watchState);\n  }\n  const injector = config?.injector ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  addWatcher(stateSource, watcher);\n  watcher(getState(stateSource));\n  const destroy = () => removeWatcher(stateSource, watcher);\n  destroyRef.onDestroy(destroy);\n  return {\n    destroy\n  };\n}\nfunction getWatchers(stateSource) {\n  return STATE_WATCHERS.get(stateSource[STATE_SOURCE]) || [];\n}\nfunction notifyWatchers(stateSource) {\n  const watchers = getWatchers(stateSource);\n  for (const watcher of watchers) {\n    const state = untracked(() => getState(stateSource));\n    watcher(state);\n  }\n}\nfunction addWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], [...watchers, watcher]);\n}\nfunction removeWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], watchers.filter(w => w !== watcher));\n}\nfunction signalState(initialState) {\n  const stateKeys = Reflect.ownKeys(initialState);\n  const stateSource = stateKeys.reduce((signalsDict, key) => ({\n    ...signalsDict,\n    [key]: signal(initialState[key])\n  }), {});\n  const signalState = computed(() => stateKeys.reduce((state, key) => ({\n    ...state,\n    [key]: stateSource[key]()\n  }), {}));\n  Object.defineProperty(signalState, STATE_SOURCE, {\n    value: stateSource\n  });\n  for (const key of stateKeys) {\n    Object.defineProperty(signalState, key, {\n      value: toDeepSignal(stateSource[key])\n    });\n  }\n  return signalState;\n}\nfunction signalStore(...args) {\n  const signalStoreArgs = [...args];\n  const config = typeof signalStoreArgs[0] === 'function' ? {} : signalStoreArgs.shift();\n  const features = signalStoreArgs;\n  let SignalStore = /*#__PURE__*/(() => {\n    class SignalStore {\n      constructor() {\n        const innerStore = features.reduce((store, feature) => feature(store), getInitialInnerStore());\n        const {\n          stateSignals,\n          props,\n          methods,\n          hooks\n        } = innerStore;\n        const storeMembers = {\n          ...stateSignals,\n          ...props,\n          ...methods\n        };\n        this[STATE_SOURCE] = innerStore[STATE_SOURCE];\n        for (const key of Reflect.ownKeys(storeMembers)) {\n          this[key] = storeMembers[key];\n        }\n        const {\n          onInit,\n          onDestroy\n        } = hooks;\n        if (onInit) {\n          onInit();\n        }\n        if (onDestroy) {\n          inject(DestroyRef).onDestroy(onDestroy);\n        }\n      }\n      /** @nocollapse */\n      static Éµfac = function SignalStore_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || SignalStore)();\n      };\n      /** @nocollapse */\n      static Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: SignalStore,\n        factory: SignalStore.Éµfac,\n        providedIn: config.providedIn || null\n      });\n    }\n    return SignalStore;\n  })();\n  (() => {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n  return SignalStore;\n}\nfunction getInitialInnerStore() {\n  return {\n    [STATE_SOURCE]: {},\n    stateSignals: {},\n    props: {},\n    methods: {},\n    hooks: {}\n  };\n}\nfunction signalStoreFeature(...args) {\n  const features = typeof args[0] === 'function' ? args : args.slice(1);\n  return inputStore => features.reduce((store, feature) => feature(store), inputStore);\n}\nfunction type() {\n  return undefined;\n}\nfunction assertUniqueStoreMembers(store, newMemberKeys) {\n  const storeMembers = {\n    ...store.stateSignals,\n    ...store.props,\n    ...store.methods\n  };\n  const overriddenKeys = Reflect.ownKeys(storeMembers).filter(memberKey => newMemberKeys.includes(memberKey));\n  if (overriddenKeys.length > 0) {\n    console.warn('@ngrx/signals: SignalStore members cannot be overridden.', 'Trying to override:', overriddenKeys.map(key => String(key)).join(', '));\n  }\n}\nfunction withProps(propsFactory) {\n  return store => {\n    const props = propsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, Reflect.ownKeys(props));\n    }\n    return {\n      ...store,\n      props: {\n        ...store.props,\n        ...props\n      }\n    };\n  };\n}\nfunction withComputed(computedFactory) {\n  return withProps(store => {\n    const computedResult = computedFactory(store);\n    const computedResultKeys = Reflect.ownKeys(computedResult);\n    return computedResultKeys.reduce((prev, key) => {\n      const signalOrComputation = computedResult[key];\n      return {\n        ...prev,\n        [key]: isSignal(signalOrComputation) ? signalOrComputation : computed(signalOrComputation)\n      };\n    }, {});\n  });\n}\n\n/**\n * @description\n * Allows passing properties, methods, or signals from a SignalStore\n * to a feature.\n *\n * @usageNotes\n * ```typescript\n * signalStore(\n *   withMethods((store) => ({\n *     load(id: number): Observable<Entity> {\n *       return of({ id, name: 'John' });\n *     },\n *   })),\n *   withFeature(\n *     // ðŸ‘‡ has full access to the store\n *     (store) => withEntityLoader((id) => firstValueFrom(store.load(id)))\n *   )\n * );\n * ```\n *\n * @param featureFactory function returning the actual feature\n */\nfunction withFeature(featureFactory) {\n  return store => {\n    const storeForFactory = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    };\n    return featureFactory(storeForFactory)(store);\n  };\n}\nfunction withHooks(hooksOrFactory) {\n  return store => {\n    const storeMembers = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    };\n    const hooks = typeof hooksOrFactory === 'function' ? hooksOrFactory(storeMembers) : hooksOrFactory;\n    const mergeHooks = (currentHook, hook) => {\n      return hook ? () => {\n        if (currentHook) {\n          currentHook();\n        }\n        hook(storeMembers);\n      } : currentHook;\n    };\n    return {\n      ...store,\n      hooks: {\n        onInit: mergeHooks(store.hooks.onInit, hooks.onInit),\n        onDestroy: mergeHooks(store.hooks.onDestroy, hooks.onDestroy)\n      }\n    };\n  };\n}\n\n/**\n * @description\n *\n * Adds linked state slices to a SignalStore.\n *\n * @usageNotes\n *\n * ```typescript\n * const OptionsStore = signalStore(\n *   withState({ options: [1, 2, 3] }),\n *   withLinkedState(({ options }) => ({\n *     selectedOption: () => options()[0],\n *   }))\n * );\n * ```\n *\n * This returns a state of type `{ options: number[], selectedOption: number | undefined }`.\n * When the `options` signal changes, the `selectedOption` automatically updates.\n *\n * For advanced use cases, `linkedSignal` or any other `WritableSignal` instance can be used within `withLinkedState`:\n *\n * ```typescript\n * type Option = { id: number; label: string };\n *\n * const OptionsStore = signalStore(\n *   withState({ options: [] as Option[] }),\n *   withLinkedState(({ options }) => ({\n *     selectedOption: linkedSignal<Option[], Option>({\n *       source: options,\n *       computation: (newOptions, previous) => {\n *         const option = newOptions.find((o) => o.id === previous?.value.id);\n *         return option ?? newOptions[0];\n *       },\n *     })\n *   }))\n * )\n * ```\n *\n * @param linkedStateFactory A function that returns an object literal with properties containing an actual `linkedSignal` or the computation function.\n */\nfunction withLinkedState(linkedStateFactory) {\n  return store => {\n    const linkedState = linkedStateFactory({\n      ...store.stateSignals,\n      ...store.props\n    });\n    const stateKeys = Reflect.ownKeys(linkedState);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, stateKeys);\n    }\n    const stateSource = store[STATE_SOURCE];\n    const stateSignals = {};\n    for (const key of stateKeys) {\n      const signalOrComputationFn = linkedState[key];\n      stateSource[key] = isWritableSignal(signalOrComputationFn) ? signalOrComputationFn : linkedSignal(signalOrComputationFn);\n      stateSignals[key] = toDeepSignal(stateSource[key]);\n    }\n    return {\n      ...store,\n      stateSignals: {\n        ...store.stateSignals,\n        ...stateSignals\n      }\n    };\n  };\n}\nfunction withMethods(methodsFactory) {\n  return store => {\n    const methods = methodsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, Reflect.ownKeys(methods));\n    }\n    return {\n      ...store,\n      methods: {\n        ...store.methods,\n        ...methods\n      }\n    };\n  };\n}\nfunction withState(stateOrFactory) {\n  return store => {\n    const state = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n    const stateKeys = Reflect.ownKeys(state);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      assertUniqueStoreMembers(store, stateKeys);\n    }\n    const stateSource = store[STATE_SOURCE];\n    const stateSignals = {};\n    for (const key of stateKeys) {\n      stateSource[key] = signal(state[key]);\n      stateSignals[key] = toDeepSignal(stateSource[key]);\n    }\n    return {\n      ...store,\n      stateSignals: {\n        ...store.stateSignals,\n        ...stateSignals\n      }\n    };\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { deepComputed, getState, isWritableStateSource, patchState, signalMethod, signalState, signalStore, signalStoreFeature, type, watchState, withComputed, withFeature, withHooks, withLinkedState, withMethods, withProps, withState };\n","import { of, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, map, catchError, tap, finalize } from 'rxjs/operators';\n\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nfunction concatLatestFrom(observablesFactory) {\n  return concatMap(value => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom(...observablesAsArray));\n  });\n}\n\n/**\n * `mapResponse` is a map operator with included error handling.\n * It is similar to `tapResponse`, but allows to map the response as well.\n *\n * The main use case is for NgRx Effects which requires an action to be dispatched.\n *\n * @usageNotes\n * ```ts\n * export const loadAllUsers = createEffect((\n *   actions$ = inject(Actions),\n *   usersService = inject(UsersService)\n * ) => {\n *   return actions$.pipe(\n *     ofType(UsersPageActions.opened),\n *     exhaustMap(() => {\n *       return usersService.getAll().pipe(\n *         mapResponse({\n *           next: (users) => UsersApiActions.usersLoadedSuccess({ users }),\n *           error: (error) => UsersApiActions.usersLoadedFailure({ error }),\n *         })\n *       );\n *     })\n *   );\n * });\n * ```\n */\nfunction mapResponse(observer) {\n  return source$ => source$.pipe(map(value => observer.next(value)), catchError(error => of(observer.error(error))));\n}\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly loadUsers = rxMethod<void>(\n *   pipe(\n *     tap(() => this.isLoading.set(true)),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.users.set(users),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.isLoading.set(false),\n *         })\n *       )\n *     )\n *   )\n * );\n * ```\n */\nfunction tapResponse(observerOrNext, error, complete) {\n  const observer = typeof observerOrNext === 'function' ? {\n    next: observerOrNext,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: error,\n    complete\n  } : observerOrNext;\n  return source => source.pipe(tap({\n    next: observer.next,\n    complete: observer.complete\n  }), catchError(error => {\n    observer.error(error);\n    return EMPTY;\n  }), observer.finalize ? finalize(observer.finalize) : source$ => source$);\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { concatLatestFrom, mapResponse, tapResponse };\n","import { assertInInjectionContext, inject, Injector, DestroyRef, isSignal, effect, untracked } from '@angular/core';\nimport { Subject, noop, isObservable } from 'rxjs';\nfunction rxMethod(generator, config) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && !config?.injector) {\n    assertInInjectionContext(rxMethod);\n  }\n  const sourceInjector = config?.injector ?? inject(Injector);\n  const source$ = new Subject();\n  const sourceSub = generator(source$).subscribe();\n  sourceInjector.get(DestroyRef).onDestroy(() => sourceSub.unsubscribe());\n  const rxMethodFn = (input, config) => {\n    if (isStatic(input)) {\n      source$.next(input);\n      return {\n        destroy: noop\n      };\n    }\n    const callerInjector = getCallerInjector();\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && config?.injector === undefined && callerInjector === undefined) {\n      console.warn('@ngrx/signals/rxjs-interop: The reactive method was called outside', 'the injection context with a signal or observable. This may lead to', 'a memory leak. Make sure to call it within the injection context', '(e.g. in a constructor or field initializer) or pass an injector', 'explicitly via the config parameter.\\n\\nFor more information, see:', 'https://ngrx.io/guide/signals/rxjs-integration#reactive-methods-and-injector-hierarchies');\n    }\n    const instanceInjector = config?.injector ?? callerInjector ?? sourceInjector;\n    if (isSignal(input)) {\n      const watcher = effect(() => {\n        const value = input();\n        untracked(() => source$.next(value));\n      }, {\n        injector: instanceInjector\n      });\n      sourceSub.add({\n        unsubscribe: () => watcher.destroy()\n      });\n      return watcher;\n    }\n    const instanceSub = input.subscribe(value => source$.next(value));\n    sourceSub.add(instanceSub);\n    if (instanceInjector !== sourceInjector) {\n      instanceInjector.get(DestroyRef).onDestroy(() => instanceSub.unsubscribe());\n    }\n    return {\n      destroy: () => instanceSub.unsubscribe()\n    };\n  };\n  rxMethodFn.destroy = sourceSub.unsubscribe.bind(sourceSub);\n  return rxMethodFn;\n}\nfunction isStatic(value) {\n  return !isSignal(value) && !isObservable(value);\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { rxMethod };\n","import { patchState, signalStore, withMethods, withState } from '@ngrx/signals';\r\nimport { rxMethod } from '@ngrx/signals/rxjs-interop';\r\nimport { debounceTime, finalize, Observable, pipe, switchMap, tap } from 'rxjs';\r\n\r\nexport type WithCallbacks<T, S> = {\r\n  data: T;\r\n  onSuccess?: (response: S) => void;\r\n  onError?: (error: any) => void;\r\n};\r\n\r\ntype GlobalStore = {\r\n  isSubmitting: boolean;\r\n};\r\n\r\nconst initialState: GlobalStore = {\r\n  isSubmitting: false,\r\n};\r\n\r\nexport const GlobalStore = signalStore(\r\n  { providedIn: 'root' },\r\n  withState(initialState),\r\n  withMethods((store) => ({\r\n    withFormSubmission<T, S>(source$: (source: T) => Observable<S>) {\r\n      return rxMethod<WithCallbacks<T, S>>(\r\n        pipe(\r\n          tap(() => patchState(store, { isSubmitting: true })),\r\n          debounceTime(300),\r\n          switchMap((cb) =>\r\n            source$(cb.data).pipe(\r\n              tap({\r\n                next: (response) => {\r\n                  cb.onSuccess?.(response);\r\n                },\r\n                error: (error) => {\r\n                  cb.onError?.(error);\r\n                },\r\n              }),\r\n              finalize(() => {\r\n                patchState(store, { isSubmitting: false });\r\n              })\r\n            )\r\n          )\r\n        )\r\n      );\r\n    },\r\n    withApiState<T, S>(source$: (data: T) => Observable<S>) {\r\n      return rxMethod<T>(pipe(switchMap(source$)));\r\n    },\r\n  }))\r\n);\r\n"],"mappings":"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","names":["ToastService","toasts","signal","counter","show","message","type","duration","id","newToast","set","setTimeout","remove","filter","t","factory","Éµfac","providedIn","DEEP_SIGNAL","toDeepSignal","signal","target","prop","value","untracked","isRecord","isSignal","computed","nonRecords","isIterable","proto","STATE_WATCHERS","STATE_SOURCE","patchState","stateSource","updaters","currentState","untracked","getState","newState","nextState","updater","__spreadValues","signals","STATE_SOURCE","stateKeys","key","signalKey","notifyWatchers","state","value","__spreadProps","watchState","watcher","config","destroyRef","inject","Injector","DestroyRef","addWatcher","destroy","removeWatcher","getWatchers","STATE_WATCHERS","watchers","w","signalStore","args","signalStoreArgs","config","features","SignalStore","innerStore","store","feature","getInitialInnerStore","stateSignals","props","methods","hooks","storeMembers","__spreadValues","STATE_SOURCE","key","onInit","onDestroy","inject","DestroyRef","__ngFactoryType__","ÉµÉµdefineInjectable","signalStoreFeature","inputStore","withProps","propsFactory","store","props","__spreadValues","STATE_SOURCE","__spreadProps","withHooks","hooksOrFactory","store","storeMembers","__spreadValues","STATE_SOURCE","hooks","mergeHooks","currentHook","hook","__spreadProps","withMethods","methodsFactory","store","methods","__spreadValues","STATE_SOURCE","__spreadProps","withState","stateOrFactory","state","stateKeys","stateSource","stateSignals","key","signal","toDeepSignal","tapResponse","observerOrNext","error","complete","observer","source","tap","catchError","EMPTY","finalize","source$","rxMethod","generator","config","sourceInjector","inject","Injector","source$","Subject","sourceSub","DestroyRef","rxMethodFn","input","isStatic","noop","callerInjector","getCallerInjector","instanceInjector","isSignal","watcher","effect","value","untracked","instanceSub","isObservable","initialState","isSubmitting","GlobalStore","signalStore","providedIn","withState","withMethods","store","withFormSubmission","source$","rxMethod","pipe","tap","patchState","debounceTime","switchMap","cb","data","next","response","onSuccess","error","onError","finalize","withApiState"],"x_google_ignoreList":[1,2,3]}